(* Mathematica package *)

BeginPackage["WaveletWare`PlottingFunctions`",{"WaveletWare`CommonUsage`","WaveletWare`MiscFunctions`","WaveletWare`PacketTransforms`"}]

(* Exported symbols added here with SymbolName::usage *)

(* Plotting functions *)

MatrixStretch::usage="MatrixStretch[a,{x,y}] linearly maps Abs[a] from (Min[a],x) to (Max[a],y)."
ImagePlot::usage="ImagePlot[a,opts] is a function that produces an image graphic.  The input a can be data supplied by ImageRead, a matrix, or a list of three matrices of equal dimension."
WaveletPlot::usage="WaveletPlot[a,opts] or WaveletPlot[a,tree,opts] plots a 2-dimensional wavelet or wavelet packet transform."
WaveletVectorPlot::usage="WaveletVectorPlot[v,opts] or WaveletVectorPlot[v,tree,opts] plots a 1-dimensional wavelet or wavelet packet transform."
FullWaveletVectorPlot::usage="FullWaveletVectorPlot[data,opts] creates a list of plots of the data generated by WTFull or WPTFull."
FullWaveletPlot::usage="FullWaveletPlot[data,opts] creates a list of plots of the data generated by WTFull or WPTFull."
ShowBestBasis::usage="ShowBestBasis[tree,opts] gives a graphical representation of the best basis generated by BestBasisTree."
WaveletRegionPlot::usage="WaveletRegionPlot[data,iter,opts] or WaveletRegionPlot[data,tree,iter,opts] takes a vector, a matrix or list of three matrices with equal dimensions, a list of ordered pairs (vector), triples  triples (grayscale matrix or wavelet transform of a color image) or 4-tuples (wavelet packet transform of a color image) and an optional fixed tree (packets) and returns that portion of the wavelet transform."


(* Options for plotting functions *)

IntensityRange::usage="IntensityRange is an option for MatrixStretch.  It is a list of two values indicating the min/max of the intensity range use to scale the input matrix."
PlotType::usage="PlotType is an option for WaveletPlot that if set to Automatic (default), plots wavelet transformed data.  It can also be set to Left or Right to plot the output of LeftWT, RightWT, respectively."
DivideLines::usage="DivideLines is an option for WaveletPlot, FullWaveletPlot, WaveletVectorPlot and FullWaveletVectorPlot that indicates whether or not different portions of the transform should be separated by dividing lines."
DivideLinesColor::usage="DivideLinesColor is an option for WaveletPlot, FullWaveletPlot, WaveletVectorPlot and FullWaveletVectorPlot that indicates the color of divide lines."
PlotTogether::usage="PlotTogether is an option for ImagePlot, WaveletPlot, FullWaveletPlot, and WaveletRegionPlot.  If set to True, an input list of three matrices are plotted as a color image.  Otherwise each channel is plotted separately."
Dimming::usage="Dimming is an option for WaveletPlot, WaveletVectorPlot, FullWaveletPlot and FullWaveletVectorPlot.  It sets the color of those portions of the transform not to be plotted."
DimmingRange::usage="DimmingRange is an option for WaveletPlot or FullWaveletPlot.  It sets the intensity range for those portions of the wavelet transformed that are dimmed."
Scaling::usage="Scaling is an option for ImagePlot, WaveletPlot, FullWaveletPlot and WaveletRegionPlot.  If set to True (default), the data are scaled before plotting.  If set to False, raw data are plotted."
Colors::usage="Colors is an option for WaveletRegionPlot, WaveletVectorPlot and FullWaveletVectorPlot.  It is a list of colors to be used when plotting iterations of the wavelet (packet) transform."
PacketPlot::usage="PacketPlot is an option for FullWaveletVectorPlot or FullWaveletPlot that indicates whether or not the input data was generated by a wavelet packet transform."
PresentationStyle::usage="PresentationStyle is an option for FullWaveletVectorPlot, FullWaveletPlot and WaveletRegionPlot that indicates how the plots should be displayed."
ColorOn::usage="ColorOn is an option for ShowBestBasis that sets the color used to indicate an element of the best basis."
ColorOff::usage="ColorOff is an option for ShowBestBasis that sets the color used to indicate an element is not part of the best basis."
BoundaryColor::usage="BoundaryColor is an option for ShowBestBasis that sets the boundary color of each portion of the packet transform."
OpacityOn::usage="OpacityOn is an option for ShowBestBasis that sets the opacity level for the elements that are part of the best basis."
OpacityOff::usage="OpacityOff is an option for ShowBestBasis that sets the opacity level for the elements that are not part of the best basis."
Show3D::usage="Show3D is an option for ShowBestBasis that provides a 3-dimensional graphic for the best basis of packet transforms of matrices."

Options[MatrixStretch]={IntensityRange->{0,255}};
Options[ImagePlot]=Join[{ChannelColor->White,Border->True,BorderColor->Black,Scaling->False,PlotTogether->True},Options[Image],Options[Raster]];
Options[WaveletPlot]=Join[{PlotType->Automatic,Iteration->All,NumIterations->1,PlotTogether->False,Scaling->True,ChannelColor->White,Dimming->GrayLevel[.8],DimmingRange->{200,255},DivideLines->True,DivideLinesColor->White,Border->True,BorderColor->Black},Options[Image],Options[Raster]];
Options[WaveletVectorPlot]={NumIterations->1,Iteration->All,DivideLines->True,DivideLinesColor->Gray,Colors->Join[ColorData[85, "ColorList"], ColorData[84, "ColorList"],ColorData[84, "ColorList"]],ImageSize->Automatic,Dimming->GrayLevel[.8],Background->White,Joined->False,PointSize->.01,Ticks->Automatic};
Options[FullWaveletVectorPlot]={PacketPlot->False,Iteration->All,DivideLines->True,DivideLinesColor->Gray,Colors->Join[ColorData[85, "ColorList"], ColorData[84, "ColorList"],ColorData[84, "ColorList"]],ImageSize->Automatic,Dimming->GrayLevel[.8],Background->White,Joined->False,PointSize->.01,Ticks->Automatic,PresentationStyle->{}};
Options[FullWaveletPlot]=Join[{PacketPlot->False,Iteration->All,PlotTogether->False,Scaling->True,Dimming->GrayLevel[.8],DimmingRange->{200,255},DivideLines->True,DivideLinesColor->White,Border->True,BorderColor->Black,ChannelColor->White,PresentationStyle->{}},Options[Raster],Options[Image]];
Options[ShowBestBasis]={ColorOn->Darker[Gray],ColorOff->White,BoundaryColor->Black,Frame->All,PlotLabel->{},LabelStyle->{},ImageSize->Automatic,OpacityOn->.75,OpacityOff->.3,Show3D->True};
Options[WaveletRegionPlot]={NumIterations->1,ChannelColor->White,Border->True,BorderColor->Black,Scaling->True,PlotTogether->False,Colors->Join[ColorData[85, "ColorList"], ColorData[84, "ColorList"],ColorData[84, "ColorList"]],Background->White,Joined->False,PointSize->0.01,Ticks->Automatic,ImageSize->Automatic,PresentationStyle->{}};

Begin["`Private`"]
(* Implementation of the package *)

(* Plotting functions *)

MatrixStretch[a_,OptionsPattern[]]:=Module[{mn=Min[Abs[a]],mx=Max[Abs[a]],x,y},
	{x,y}=OptionValue[MatrixStretch,IntensityRange];
	If[!(AllTrue[{x,y},NumberQ]&&x<=y),Message[MatrixStretch::"badrange"];Return[{}]];
	If[!MatrixQ[a],Message[MatrixStretch::"badinput"];Return[{}]];
	If[mn==mx,Return[a],Return[Round[(y-x)*(Abs[a]-mn)/(mx-mn)+x]]];
];

ImagePlot[a_,OptionsPattern[]]:=Module[{datatype,rows,cols,chlclr,bdr,bdrclr,scaling,together,f,ropts,iopts,data},
	(* Check the data integrity *)
	datatype=First[CheckData[a]];
	If[!MemberQ[{2,3},datatype],Message[ImagePlot::"badinput"];Return[{}]];

	(* Get image dimensions *)
	{rows,cols}=If[datatype==2,Dimensions[a],Dimensions[First[a]]];
	
	(* Get the indigenous options *)
	{chlclr,bdr,bdrclr,scaling,together}=OptionValue[ImagePlot,{ChannelColor,Border,BorderColor,Scaling,PlotTogether}];
	{scaling,together}=Map[TrueFalse,{scaling,together}];

	(* Override the PlotTogether setting if ChannelColor is a list of three colors *)
	If[AllTrue[chlclr,ColorQ]&&ArrayQ[chlclr]&&Length[chlclr]==3,together=False];

	(* Get all the option values for eventual call to Image, Raster. *)
	f[x_]:=MapThread[#1->#2&,{Keys[Options[x]],Map[OptionValue[ImagePlot,#]&,Keys[Options[x]]]}];
	{ropts,iopts}=Map[f,{Raster,Image}];	
	
	(* First do any scaling of the data *)
	If[scaling,
		data=If[datatype==2,ConstantArray[MatrixStretch[a],3],Map[MatrixStretch,a]],
		data=If[datatype==2,ConstantArray[a,3],a];
	];
	
	(*
	(* Adjust for the case where PlotTogether is False *)
	If[!together,data=Map[ConstantArray[#,3]&,data]];
	*)
	
	
	(* Add the channel color *)
	chlclr=CheckColor[chlclr,datatype,together];
	
	If[datatype==2||(datatype==3&&together),
		data=MapThread[#1*#2&,{data,chlclr}],
		(*f[x_,y_]:=MapThread[(#1*#2)&,{x,y}];*)
		f[x_,y_]:=Map[(x*#)&,y];
		data=MapThread[f[#1,#2]&,{data,chlclr}];
	];
	
	(* If requested, add a border (or borders) *)
	If[bdr,
		bdrclr=CheckColor[bdrclr,datatype,together];
		f[m_,x_]:=ReplacePart[m,{{_,-1}->255*x,{_,1}->255*x,{-1,_}->255*x,{1,_}->255*x}];
		If[datatype==2||(datatype==3&&together),
			data=MapThread[f,{data,bdrclr}],
			data=MapThread[f,{data,bdrclr},2];
		];
	];
	
	(* Plot the image or if PlotTogether is False, the three images *)
	f[x_]:=Module[{y},
		y=Reverse[Partition[Transpose[Map[Flatten,x]],cols]];
		Return[Image[Raster[y,{{0,0},{rows,cols}},{0,255},Evaluate@ropts],Evaluate@iopts]];
	];
	
	If[datatype==2||(datatype==3&&together),Return[f[data]]];
	If[datatype==3&&!together,Return[Map[f,data]]];
	
];

WaveletPlot[a_,t___,OptionsPattern[]]:=Module[{datatype,maxits,rows,cols,its,tmp,iter,iterall,ptype,together,scaling,chlclr,dim,dimrange,dvd,dvdclr,bdr,bdrclr,iteroff,f,dataon,dataoff,dmat,imageopts,rasteropts},
	{datatype,maxits}=CheckData[a];
	{rows,cols}=If[datatype==2,Dimensions[a],Dimensions[First[a]]];
	If[!MemberQ[{2,3},datatype],Message[WaveletPlot::"badinput"];Return[{}]];
	
	(* Grab indigenious options *)
	{ptype,iter,its,together,scaling,chlclr,dim,dimrange,dvd,dvdclr,bdr,bdrclr}=OptionValue[WaveletPlot,{PlotType,Iteration,NumIterations,PlotTogether,Scaling,ChannelColor,Dimming,DimmingRange,DivideLines,DivideLinesColor,Border,BorderColor}];
	{together,scaling,dvd,bdr}=Map[TrueFalse, {together,scaling,dvd,bdr}];
	If[!CheckIterations[its,maxits],Message[WaveletPlot::"baditerations",maxits];its=0];

	(* Set the value of ptype *)
	ptype = If[MemberQ[{Left, Right}, ptype], ptype, Automatic];
	its=If[ptype===Automatic,its,1];	
	(* Figure out which regions to plot/not plot *)
	If[ptype===Automatic,
		(* Check the integrity of the DimmingRange list *)
		If[!(VectorQ[dimrange]&&Length[dimrange]==2&&First[dimrange]<=Last[dimrange]&&AllTrue[dimrange,MemberQ[Range[0,255],#]&]),
			Message[WaveletPlot::"baddimmingrange"];dimrange=DimmingRange/.Options[WaveletPlot];
		];
  		tmp=If[t==="",
  			If[datatype==2,WaveletTree[its,InputDimension->2],ConstantArray[WaveletTree[its,InputDimension->2],3]],
  			If[IntegerQ[CheckTree[t,2]]&&datatype==3,{t,t,t},t]
  		];
  		its=CheckTree[tmp,datatype];
		{dataon,iter}=If[iter==={},{a,{}},WaveletRegionTake[a,t,iter,NumIterations->its,ReturnIterationList->True]];
		(* Check if the choice of iterations allows PlotTogether to be set to True *)
  		If[datatype==3&&together,
   			If[Mod[Length[iter],3]!=0,Message[WaveletPlot::"plottogether"];together=False]; 
    		If[!AllTrue[Partition[iter,3],Apply[Equal,Map[Rest,#]]&],Message[WaveletPlot::"plottogether"];together=False];
   		];
  
  		iterall=Which[tmp==={1},{{0,1,1}},tmp==={{1},{1},{1}},{{1,0,1,1},{2,0,1,1},{3,0,1,1}},datatype==2,Position[Rest[tmp],1],True,Position[Map[Rest,tmp],1]];
  		iteroff=Complement[iterall,iter];
  
  		(* Now check if we can plot together *)
  		If[datatype==3&&together&&!Apply[Equal,tmp],Message[WaveletPlot::"plottogether"];together=False];
   		together=If[datatype==2,False,If[Apply[Equal,tmp]&&together,True,False]];
  
  		(* Create matrices for the regions to plot (dataon) and the regions not to plot (dataoff) *)
  		f[i_,sc_,dr_]:=Module[{c,p,q,r,canvas,z,blk},
    		canvas=ConstantArray[0,{rows,cols}];
    		z=ConstantArray[SparseArray[{1,1}->0,{rows,cols}],3];
    		If[i==={},If[datatype==2,Return[canvas],Return[z]]];
    		If[datatype==2,{p,q,r}=i,{c,p,q,r}=i];
    		blk=If[datatype==2,Partition[a,{rows,cols}/2^p][[q,r]],Partition[a[[c]],{rows,cols}/2^p][[q,r]]];
    		blk=If[sc,MatrixStretch[blk,IntensityRange->dr],blk];
    		canvas=ArrayFlatten[ReplacePart[Partition[canvas,{rows,cols}/2^p],{q,r}->blk]];
    		If[datatype==2,Return[canvas],z[[c]]=canvas;Return[z]];
    	];
  		{dataon,dataoff}={Total[Map[f[#,scaling,{0,255}]&,iter]],Total[Map[f[#,True,dimrange]&,iteroff]]},
  
  		(* The case where plot type is either Left or Right *)
  		tmp={{1,1,1},If[ptype===Left,{1,2,1},{1,1,2}]};
  		f[x_]:=Map[Prepend[x,#]&,Range[3]];
  		iterall=If[datatype==2,tmp,Apply[Join,Map[f,tmp]]];
  		iter=If[iter===All,iterall,iter];
  		If[datatype==3,
   			f[i_]:=If[First[i]===All,Map[Prepend[Rest[i],#]&,Range[3]],{i}];
   			iter=Apply[Join,Map[f,iter]];
   		];
 		iter=DeleteDuplicates[iter];
 		
 		(* Check if the choice of iterations allows PlotTogether to be set to True *)
  		If[datatype==3&&together,
   			If[Mod[Length[iter],3]!=0,Message[WaveletPlot::"plottogether"];together=False]; 
    		If[!AllTrue[Partition[iter,3],Apply[Equal,Map[Rest,#]]&],Message[WaveletPlot::"plottogether"];together=False];
   		];
  		If[!AllTrue[iter,MemberQ[iterall,#]&],Message[WaveletPlot::"baditeration"];Return[{}]]; 
     	iteroff=Complement[iterall,iter];
     	     	
  		f[i_,sc_,dr_]:=Module[{c,p,q,r,canvas,z,blk,n,d,idx},
    		canvas=If[ptype===Left,ConstantArray[0,{rows/2,cols}],ConstantArray[0, {cols/2, rows}]];
    		z=ConstantArray[SparseArray[{1,1}->0,{rows,cols}],3];
    		If[i==={},If[datatype==2,Return[First[z]],Return[z]]];
    		If[datatype==2,{p,q,r}=i,{c,p,q,r}=i];
    		{d,n,idx}=If[ptype===Left,{a,rows,q},{If[datatype==2,Transpose[a],Map[Transpose,a]],cols,r}];
    		blk=If[datatype==2,Partition[d,n/2],Partition[d[[c]],n/2]][[idx]];
    		blk=If[sc,MatrixStretch[blk,IntensityRange->dr],blk];
    		canvas=If[idx==1,Join[blk,canvas],Join[canvas,blk]];
    		canvas=If[ptype===Left,canvas,Transpose[canvas]];
    		If[datatype==2,Return[canvas],z[[c]]=canvas;Return[z]];
    	];
  		{dataon,dataoff}={Total[Map[f[#,scaling,{0,255}]&,iter]],Total[Map[f[#,True,dimrange]&,iteroff]]};
  ];
 
  (*Add the channel color*)
  {chlclr,dim}=Map[CheckColor[#,datatype,together]&,{chlclr,dim}];
  
  f[d_,clr_,df_]:=Module[{g,dta},
  	If[d==0,Return[0]];
   	Which[
   		datatype==2,
   			dta=Map[(d*#)&,clr],
   		datatype==3&&!together,
   			g[x_, y_]:=Map[(x*#)&,y];
    		dta=MapThread[g[#1,#2]&,{d,clr}],
    	datatype==3&&together&&df==1,
    		dta=MapThread[(#1*#2)&,{d,clr}],
    	True,
    		dta=d
    ];
   	Return[dta];
  ];
  dataon=f[dataon,chlclr,0]+f[dataoff,dim,If[datatype==3&&together,1,0]];
 
  (* Add dividelines if requested *)
  If[dvd,
  		dvdclr=CheckColor[dvdclr,datatype,together];
  		If[ptype===Automatic,
  			f[tr_]:=Module[{MkBdr,s=ConstantArray[1,{rows,cols}],fct},
     			MkBdr[mat_,x_]:=If[x==1,Return[ReplacePart[mat,{{-1,_}->0,{1,_}->0,{_,-1}->0,{_,1}->0}]],Return[mat]];
     			fct[k_]:= ArrayFlatten[MapThread[MkBdr[#1,#2]&,{Partition[s,{rows,cols}/2^k],tr[[k]]},2]];
     			Return[Apply[Times, Map[fct, Range[its]]]];
     		];
   			iter=If[datatype==2,ConstantArray[f[Rest[tmp]],3],Map[f[Rest[#]]&,tmp]];
   			dmat=255*(1-iter),
   			iter=ConstantArray[ReplacePart[ConstantArray[1,{rows,cols}],If[ptype===Left,{rows/2,_},{_,cols/2}]->0],3];	
   			dmat=255*(1-iter);
   		];
   		If[datatype==2||(datatype==3&&together),dataon=MapThread[#1*#2&,{dataon,iter}]];
  		If[datatype==3&&!together,f[x_,y_]:= Map[y*#&,x];dataon=MapThread[f[#1,#2]&,{dataon,iter}];];
  		If[datatype==2||(datatype==3&&together),dataon=dataon+MapThread[#1*#2&,{dvdclr,dmat}];];
  		If[datatype==3&&!together,f[x_,y_]:=Map[y*#&,x];dataon=dataon+MapThread[f[#1,#2]&,{dvdclr, dmat}];];
  ];
  (*Etch out the border and create border matrix if requested*)
  
  If[bdr,
  	bdrclr=CheckColor[bdrclr,datatype,together];
  	f[mat_]:=ReplacePart[mat,{{_,1|cols}->0,{1|rows,_}->0}];
  	dmat=ConstantArray[SparseArray[{{_,1|cols}->255,{1|rows,_}->255},{rows,cols}],3];
  	If[datatype==2||(datatype==3&&together),dataon=Map[f,dataon]];
  	If[datatype==3&&!together,dataon=Map[f,dataon,{2}]];
  	If[datatype==2||(datatype==3&&together),dataon=dataon+MapThread[#1*#2&,{bdrclr,dmat}];];
  	If[datatype==3&&!together,f[x_,y_]:=Map[y*#&,x];dataon=dataon+MapThread[f[#1,#2]&,{bdrclr,dmat}];];
  ];
  
  (*Set up the data and create plot*)
  f[x_]:=MapThread[(#1->#2)&,{Keys[Options[x]],Map[OptionValue[WaveletPlot,#]&,Keys[Options[x]]]}];
  {imageopts,rasteropts}=Map[f,{Image,Raster}];
  
  f[x_]:=Module[{y},
  	y = Reverse[Partition[Transpose[Map[Flatten, x]], cols]];
   	Return[Image[Raster[y,{{0,0},{rows,cols}},{0,255},Evaluate@rasteropts], Evaluate@imageopts]];
   ];
   
   If[datatype==2||(datatype==3&&together),Return[f[dataon]]];
   If[datatype==3&&!together,Return[Map[f,dataon]]];
];


WaveletVectorPlot[v_,t___,OptionsPattern[]]:=Module[{datatype,maxits,n,its,iter,dvd,dvdclr,clrs,imgsize,dim,back,joined,ptsize,tree,pts,ptree,f,on,off,pstyle,tix},
	(* Check the data integrity *)
	{datatype,maxits}=CheckData[v];
	If[datatype!=1,Message[WaveletVectorPlot::"badinput"];Return[{}]];
	n=Length[v];
	
	(* Get all indigenious option values *)
	{its,iter,dvd,dvdclr,clrs,imgsize,dim,back,joined,ptsize,tix}=OptionValue[WaveletVectorPlot,{NumIterations,Iteration,DivideLines,DivideLinesColor,Colors,ImageSize,Dimming,Background,Joined,PointSize,Ticks}];
	{dvd,joined}=Map[TrueFalse,{dvd,joined}];
	
	(* Check the iterations and get the tree - if no tree is given, generate a WaveletTree *)
	{its,tree}=If[t==="",{its,WaveletTree[its,InputDimension->1]},{CheckTree[t,1],t}];
	If[its==False,Message[WaveletVectorPlot::"badtree"];Return[{}];];
	If[!CheckIterations[its,maxits],Message[WaveletVectorPlot::"baditerations",maxits];its=0];
	
	
	(* Check Iteration, Colors, DivideLinesColor and Opacity *)
	If[!AllTrue[iter,CheckIterationValue[#,its,tree,datatype]&],Message[WaveletVectorPlot::"baditeration"];iter=Iteration/.Options[WaveletVectorPlot]];
	If[!ColorQ[dim],Message[WaveletVectorPlot::"badcolor","Dimming"];dim=Dimming/.Options[WaveletVectorPlot]];
	If[!ColorQ[dvdclr],Message[WaveletVectorPlot::"badcolor","DivideLinesColor"];dvdclr=DivideLinesColor/.Options[WaveletVectorPlot]];
	If[ColorQ[clrs],
		clrs=ConstantArray[clrs,its+1],
		If[AllTrue[clrs,ColorQ],
			clrs=PadRight[clrs,its+1,clrs],
			Message[WaveletVectorPlot::"badcolor","Colors"];
			clrs=Colors/.Options[WaveletVectorPlot];
		];
	];
	
	(* Take care of the trivial case *)
	If[its==0||First[tree]==1,
		Return[ListPlot[v,PlotStyle->{If[Length[clrs]==0,dim,First[clrs]],PointSize[ptsize]},PlotRange->All,Background->back,Ticks->tix,Joined->joined,ImageSize->imgsize]];
	];
	
	(* Make a new plot tree *)
	ptree=If[iter===All,Rest[tree],ReplacePart[0*Rest[tree],Map[#->1&,iter]]];
	
	(* Get the points to plot in full color and those to dim *)
	pts=Map[Partition[Transpose[{Range[0,n-1],v}],n/2^#]&,Range[its]];
	f[x_]:=Map[Extract[pts,#]&,Position[x,1]];
	{on,off}=Map[f,{ptree,Rest[tree]-ptree}];
		
	(* Set up the colors (make sure we have enough colors in the process), plotstyle *)
	clrs=PadRight[clrs,Length[on],clrs];
	If[t==="",
		clrs=If[iter===All||(ptree[[its,1]]==1 && ptree[[its,2]]==1),
				Join[Reverse[Drop[clrs,2]],Take[clrs,2]],
				Reverse[clrs]
			],
		clrs
	];
	clrs=Join[clrs,ConstantArray[dim,Length[off]]];
	pstyle=Map[{#,PointSize[ptsize]}&,clrs];
	
	(* Do the grid lines if requested *)
	dvd=If[dvd,
		{Append[Sort[Select[Flatten[Map[Range[0,n-1,n/2^#]&,Range[its]]*Rest[tree]],#!=0&]],n-1],{Min[v]-5,Max[v]+5}},
		None
	];
	(* Do the plot *)
	Return[ListPlot[Join[on,off],PlotStyle->pstyle,PlotRange->All,Background->back,Ticks->tix,Joined->joined,GridLines->dvd,GridLinesStyle->dvdclr,ImageSize->imgsize]];
];

FullWaveletVectorPlot[v_,OptionsPattern[]]:=Module[{datatype,maxits,n,m,pplot,its,iter,dvd,dvdclr,clrs,imgsize,dim,back,joined,ptsize,tix,tree,f,tmp,d,pstyle,plts},
	(* Check the data integrity *)
	datatype=Flatten[Map[DeleteDuplicates,Transpose[Map[CheckData,v]]]];
	If[Length[datatype]!=2,Message[FullWaveletVectorPlot::"badinput"];Return[{}],{datatype,maxits}=datatype];
	If[datatype!=1,Message[FullWaveletVectorPlot::"badinput"];Return[{}]];
	{its,n}={Length[v]-1,Length[First[v]]};
	
	(* Check NumIterations integrity *)
	If[!CheckIterations[its,maxits],Message[FullWaveletVectorPlot::"baditerations",maxits];Return[{}]];
	
	(* Get the indigenous option values *)
	{pplot,iter,dvd,dvdclr,clrs,imgsize,dim,back,joined,ptsize,tix,pstyle}=OptionValue[FullWaveletVectorPlot,Keys[Options[FullWaveletVectorPlot]]];
	pplot=Map[TrueFalse,pplot];
	
	(* A function for creating lists of attributes for plots *)
	f[x_,c_,test_]:=Module[{y},
			If[test==True,
				y=x,
				If[Length[x]!=its+1,
					Message[FullWaveletVectorPlot::"badvalue",c];
					y=c/.Options[FullWaveletVectorPlot],
					Return[x];
				];
			];
			Return[ConstantArray[y,its+1]];
		];
	
	(* Set the plotting options up for a MapThread call to WaveletVectorPlot *)
	joined=f[joined,Joined,(joined===True||joined===False)];
	dvd=f[dvd,DivideLines,(dvd===True||dvd===False)];
	ptsize=f[ptsize,PointSize,NumberQ[ptsize]];
	back=f[back,Background,ColorQ[back]===True];
	dvdclr=f[dvdclr,DivideLinesColor,ColorQ[dvdclr]===True];
	dim=f[dim,Dimming,ColorQ[dim]===True];
	
	(* Make sure the presentation style is one of four possible values *)
	If[!(pstyle==={}||pstyle===GraphicsColumn||pstyle===GraphicsRow||pstyle===FlipView),Message[FullWaveletVectorPlot::"badpresentation"];pstyle={}];
	
	(* Create a set of trees so that divide lines are set up properly *)
	tree=Prepend[Map[ConstantArray[0,2^#]&,Range[its]],0];
	f[x_]:=If[x==0,ReplacePart[tree,1->1],ReplacePart[tree,x+1->ConstantArray[1,2^x]]];
	tree=If[pplot,
			Map[f,Range[0,its]],
			Map[WaveletTree,Range[0,its]]
	];
	
	(* Now fix up the Iteration variable we need a list of length its+1 *)
	If[iter===All,
		iter=ConstantArray[All,its+1];
		m=If[pplot,2^(its+1)-1,Total[Range[its+1]]],
		tmp=Sort[iter];
		d=DeleteDuplicates[Map[First,tmp]];
		tmp=Map[Rest,Split[tmp,First[#1]==First[#2]&],{2}];
		tmp=MapThread[#1->#2&,{d+1,tmp}];
		iter=ReplacePart[ConstantArray[{},its+1],tmp];
		m=Total[Map[Length,iter]];
	];
	
	(* Partition the colors *)
	(* Check the input color list *)
	If[!(ColorQ[clrs]||AllTrue[clrs,ColorQ]),Message[FullWaveletVectorPlot::"badcolors"];clrs=Colors/.Options[FullWaveletVectorPlot]];
	(* First get the correct number of colors *)
	clrs=If[ColorQ[clrs],ConstantArray[clrs,m],PadRight[clrs,m,clrs]];
	(* Now figure out the partitioning of the colors - this is stored in tmp *)
	If[AllTrue[iter,#===All&],
		If[!pplot,
			m=Map[Total[Range[#]]&,Range[its+1]];
			tmp=Prepend[Transpose[{Most[m+1],Rest[m]}],{1}],
			m=PowerRange[2,2^(its+1),2];
			tmp=Prepend[Transpose[{Most[m],Rest[m]-1}],{1}];
		],
		m=Accumulate[Map[Length,iter]];
		tmp=Prepend[Transpose[{Most[m+1],Rest[m]}],If[First[m]==0,{},{1}]];
	];
	(* Use Take to correctly partition the colors *)
	clrs=Map[Take[clrs,#]&,tmp];
	
	plts=MapThread[WaveletVectorPlot[#1,#2,NumIterations->#3,Iteration->#4,DivideLines->#5,DivideLinesColor->#6,Colors->#7,ImageSize->imgsize,Joined->#8,Ticks->tix,Dimming->#9,Background->#10,PointSize->#11]&,{v,tree,Range[0,its],iter,dvd,dvdclr,clrs,joined,dim,back,ptsize}];
	If[pstyle==={},Return[plts],Return[pstyle[plts]]];
];

FullWaveletPlot[a_,OptionsPattern[]]:=Module[{datatype,maxits,tmp,bdr,bdrclr,chlclr,dim,dimrange,dvd,dvdclr,imgsize,iter,its,pplot,itslist,together,pstyle,scaling,tree,f,plts,iopts,ropts},
	datatype=Flatten[Map[DeleteDuplicates,Transpose[Map[CheckData,a]]]];
	If[Length[datatype]!= 2,Message[FullWaveletPlot::"badinput"];Return[{}],{datatype,maxits}=datatype];
	If[!MemberQ[{2,3},datatype],Message[FullWaveletPlot::"badinput"];Return[{}]];
	
	
	(*Get the indigenous option values*)
	tmp=Sort[Append[Complement[Keys[Options[FullWaveletPlot]],Keys[Options[Raster]],Keys[Options[Image]]],ImageSize]];
	{bdr,bdrclr,chlclr,dim,dimrange,dvd,dvdclr,imgsize,iter,pplot,together,pstyle,scaling}=OptionValue[FullWaveletPlot, tmp];
	(* Clean up PacketPlot *)
	pplot=TrueFalse[pplot];
	(*Check NumIterations integrity*)
	its=Length[a]-1;
	If[!CheckIterations[its,maxits],Message[FullWaveletPlot::"baditerations",maxits];its = 0];
	itslist=Range[0,its];
	(*Make sure the presentation style is one of four possible values *)
	If[!(pstyle==={}||pstyle===GraphicsColumn||pstyle===GraphicsRow||pstyle===FlipView),Message[FullWaveletPlot::"badpresentation"];pstyle={}];

	(*Create a set of trees so that divide lines are set up properly*)
	(*
	tree=Prepend[Map[ConstantArray[0,{2^#,2^#}]&,Range[its]],0]; 
	f[x_]:=If[x==0,ReplacePart[tree,1 -> 1],ReplacePart[tree,x+1->ConstantArray[1,{2^x,2^x}]]];
	tree=If[pplot,Map[f,itslist],Map[WaveletTree[#,InputDimension->2]&,itslist]];
	*)
	f[i_]:=Module[{k},Return[If[i==0,{1},Prepend[Table[ConstantArray[DiscreteDelta[k-i],{2^k,2^k}],{k,1,i}],0]]]];
	tree=If[pplot,Map[f,itslist],Map[WaveletTree[#,InputDimension->2]&,itslist]];

	(* Get the iter values sorted out *)
	iter=If[iter===All,ConstantArray[All,its+1],iter];
	If[Length[iter]!=its+1,Message[FullWaveletPlot::"baditeration"]; Return[{}]];
	(* Check the validity of the iterations *)
	f[i_, it_, tr_] :=AllTrue[Map[If[#==={},True,CheckIterationValue[If[datatype==2,#,Rest[#]],it,tr,2]]&,i],#===True&];
	tmp=MapThread[f[#1,#2,#3]&,{iter,itslist,tree}];
	If[Length[Position[tmp,False]]!=0,Message[FullWaveletPlot::"baditeration"]; Return[{}]];
	
	(* Sort out all the indiginous options *)
	f[x_,c_,test_]:=Module[{y},
   		If[test==True,
   			y=x,
    		If[Length[x]!=its+1,
      			Message[FullWaveletPlot::"badvalue",c];
      			y=c/.Options[FullWaveletVectorPlot],
      			Return[x];
      		];
    	];
   		Return[ConstantArray[y,its+1]];
	];
	
	dvd=f[dvd,DivideLines,(dvd===True||dvd===False)];
	dvdclr=f[dvdclr,DivideLinesColor,ColorQ[dvdclr]===True];
	dim=f[dim,Dimming,ColorQ[dim]===True];
	dimrange=f[dimrange,DimmingRange,(VectorQ[dimrange]&&Length[dimrange]==2&&First[dimrange]<=Last[dimrange]&&AllTrue[dimrange,MemberQ[Range[0,255],#]&])];
	together=f[together,PlotTogether,(together===True||together===False)];
	scaling = f[scaling, Scaling, (scaling === True || scaling === False)];
	bdr=f[bdr,Border,(bdr===True||bdr===False)];
	bdrclr=f[bdrclr,BorderColor,ColorQ[bdrclr]===True];
	chlclr=f[chlclr,ChannelColor,(ColorQ[chlclr]||(Length[chlclr]==3&&AllTrue[chlclr,ColorQ]))];
	(* Resolve a conflict with ChannelColor and PlotTogether *)
	chlclr=ReplacePart[chlclr,Map[#->White&,Flatten[Position[together,True]]]];
	(*Set up the data and create plot*)
	f[x_]:=MapThread[(#1->#2)&,{Keys[Options[x]],Map[OptionValue[FullWaveletPlot,#]&,Keys[Options[x]]]}];
	{iopts,ropts}=Map[f,{Image, Raster}];

	(* Make the tree lists of three trees in the case where datatype=3 *)
	tree=If[datatype==3,Transpose[{tree,tree,tree}],tree];

	plts=MapThread[WaveletPlot[#1,#13,ImageSize->imgsize,NumIterations ->#2,Iteration->#3,DivideLines->#4,DivideLinesColor->#5,Dimming->#6,PlotTogether->#7,Scaling->#8,Border->#9,BorderColor->#10,DimmingRange->#11,ChannelColor->#12,Evaluate@iopts,Evaluate@ropts]&,{a,itslist,iter,dvd,dvdclr,dim,together,scaling,bdr,bdrclr,dimrange,chlclr,tree}];

	If[pstyle==={},Return[plts]];
	
	tmp=ImagePlot[ConstantArray[255,Dimensions[First[a]]],Border->False];
	plts=Map[If[Length[#]==3,#,{tmp,#,tmp}]&,plts];
	plts=Which[pstyle===GraphicsRow,Transpose[plts],pstyle===GraphicsColumn,plts,True,Map[GraphicsRow,plts]];
	pstyle=If[pstyle===FlipView,pstyle,GraphicsGrid];
	Return[pstyle[plts]];
];

ShowBestBasis[tree_,OptionsPattern[]]:=Module[{its,treetype,clron,clroff,bndclr,frame,lbl,lblstyle,imgsize,opon,opoff,show3d,f,lvls,revtree,lowleft,k,upright,plt,schematic},
	(* Check tree integrity and figure out the number of iterations *)
	treetype=If[AllTrue[Rest[tree],VectorQ],1,2];
	its=CheckTree[tree,treetype];
	
	(* Get options *)
	{clron,clroff,bndclr,frame,lbl,lblstyle,imgsize,opon,opoff,show3d}=OptionValue[ShowBestBasis,{ColorOn,ColorOff,BoundaryColor,Frame,PlotLabel,LabelStyle,ImageSize,OpacityOn,OpacityOff,Show3D}];
	
	(* Check color values *)
	{clron,clroff,bndclr}=Map[RGBColor,Map[CheckColor[#,treetype,True]&,{clron,clroff,bndclr}]];
	
	(* Check the opacity values *)
	f[x_,y_]:=Module[{},
		If[!(NumberQ[x]&&NonNegative[x]),
			Message[ShowBestBasis::"badopacity",y];
			Return[y/.Options[ShowBestBasis]],
			Return[x]
		];	
	];
	{opon,opoff}=MapThread[f[#1,#2]&,{{opon,opoff},{OpacityOn,OpacityOff}}];
		
	lvls=its+1;
	
	(* Plot the best basis for vector input *)
	If[treetype==1,
		revtree=Append[Most[Reverse[tree]], {First[tree]}];
		lowleft=Table[Transpose[{2^(k-1)*Range[0,2^(lvls-k)-1],ConstantArray[k-1,2^(lvls-k)]}],{k,1,lvls}];
		upright=Table[Map[(#+{2^(k-1),1})&,lowleft[[k]]],{k,1,lvls}];
		plt=Flatten[Table[MapThread[Graphics[{EdgeForm[Directive[Thick, bndclr]],Which[#3==0,clroff,True,clron],Rectangle[#1,#2]}]&,{lowleft[[k]],upright[[k]],revtree[[k]]}],{k,1,lvls}]];
		If[lbl==={},
			Return[Show[plt,ImageSize->imgsize]],
			Return[Labeled[Show[plt,ImageSize->imgsize],lbl,Top,LabelStyle->lblstyle]]
		];
	];
	
	(* Plot the best basis for matrix input *)
	
	(* Do the 3D plot *)
	revtree=Append[Map[Flatten[Transpose[Reverse[#]]]&,Most[Reverse[tree]]],{First[tree]}];
	lowleft=Table[Map[Append[#,k-1]&,Tuples[2^(k-1)*Range[0,2^(lvls-k)-1],2]],{k,1,lvls}];
    upright=Table[Map[(#+{2^(k-1),2^(k-1),1})&,lowleft[[k]]],{k,1,lvls}];
    plt = Flatten[Table[MapThread[Graphics3D[{Which[#3 == 0,Opacity[opoff],True,Opacity[opon]],EdgeForm[Directive[Thick,bndclr]],Which[#3==0,clroff,True,clron],Cuboid[#1,#2]}]&,{lowleft[[k]],upright[[k]],revtree[[k]]}], {k, 1, lvls}]];
    plt=Show[plt,ImageSize->imgsize,Boxed->False];
    
    (* Do the 2D schematic plot *)
    lowleft=Table[Tuples[2^(k-1)*Range[0,2^(lvls-k)-1],2],{k,1,lvls}];
    upright=Table[Map[(#+{2^(k-1),2^(k-1)})&,lowleft[[k]]],{k,1,lvls}];
    revtree=Append[Map[Flatten[Transpose[Reverse[#]]]&,Most[Reverse[tree]]],{First[tree]}];
    schematic=Map[Show,Table[MapThread[Graphics[{EdgeForm[Directive[Thick, bndclr]],Which[#3==0,clroff,True,clron],Rectangle[#1,#2]}]&,{lowleft[[k]],upright[[k]],revtree[[k]]}],{k,1,lvls}]];
    show3d=TrueFalse[show3d];
    schematic=If[show3d,GraphicsColumn[Reverse[schematic],ImageSize->imgsize],GraphicsRow[Reverse[schematic],ImageSize->imgsize]];
    If[lbl==={},
    	Return[If[show3d,GraphicsRow[{schematic,plt},Frame->frame],schematic]],
    	Return[Labeled[If[show3d,GraphicsRow[{schematic,plt},Frame->frame],schematic],lbl,Top,LabelStyle->lblstyle]]
    ];
];

WaveletRegionPlot[a_,t___,iter_,OptionsPattern[]]:=Module[{datatype,tmp,f,ld,data,newiter,chlclr,bdr,bdrclr,scaling,together,imgsize,plts,clr,back,joined,ptsize,tix,style,pstyle},
	(* Check integrity of data, the number of iterations, the tree and the iteration value *)
	datatype=First[CheckData[a]];
	
	(* Get the different portions of the data *)
	{data,newiter}=WaveletRegionTake[a,t,iter,NumIterations->OptionValue[WaveletRegionPlot,NumIterations],ReturnIterationList->True];
	ld=Length[data];
	
	(* A function for creating lists of attributes for plots *)
	f[x_,c_,test_]:=Module[{y},
			If[test==True,
				y=x,
				If[Length[x]!=ld,
					Message[WaveletRegionPlot::"badvalue",c];
					y=c/.Options[WaveletRegionPlot],
					Return[x];
				];
			];
			Return[ConstantArray[y,Length[data]]];
		];
	
	{chlclr,bdr,bdrclr,scaling,imgsize,pstyle}=OptionValue[WaveletRegionPlot,{ChannelColor,Border,BorderColor,Scaling,ImageSize,PresentationStyle}];
	together=TrueFalse[OptionValue[WaveletRegionPlot,PlotTogether]];
	(* Make sure the presentation style is one of four possible values *)
	If[!(pstyle==={}||pstyle===GraphicsColumn||pstyle===GraphicsRow||pstyle===FlipView),Message[WaveletRegionPlot::"badpresentation"];pstyle={}];

	If[datatype==3&&together&&Mod[ld,3]==0,
			data=Partition[data,3];
			(* check that the data, grouped in threes, have equal dimensions *)
			tmp=Partition[Map[Rest,newiter],3];
			If[!AllTrue[Apply[Equal,tmp,{1}],#==True&],Message[WaveletRegionPlot::"badregions"];Return[{}]];
			ld=ld/3;
			chlclr=ConstantArray[White,ld],
			chlclr=f[chlclr,ChannelColor,ColorQ[chlclr]];
	];
	
	bdr=f[bdr,Border,(Length[bdr]==0&&(bdr==True||bdr==False))];
	scaling=f[scaling,Scaling,(Length[scaling]==0&&(scaling==True||scaling==False))];
	bdrclr=f[bdrclr,BorderColor,ColorQ[bdrclr]];
	imgsize=f[imgsize,ImageSize,Length[imgsize]==0||(IntegerQ[imgsize]&&Positive[imgsize])||(VectorQ[imgsize]&&Length[imgsize]==2)];
	
	If[datatype==1,
		{clr,back,joined,ptsize,tix}=OptionValue[WaveletRegionPlot,{Colors,Background,Joined,PointSize,Ticks}];
		joined=f[joined,Joined,(Length[joined]==0&&(joined==True||joined==False))];
		back=f[back,Background,(back===None||back===Automatic||ColorQ[back])];
		ptsize=f[ptsize,PointSize,Length[ptsize]==0];
		tix=Which[
				tix===None||tix===Automatic,ConstantArray[tix,ld],
				(Length[tix]==ld&&AllTrue[tix,#===None||#===Automatic||Head[#]===List&]),tix,
				True,ConstantArray[Automatic,ld]
			];
	
		(* Set up the colors (make sure we have enough colors in the process), plotstyle *)
		clr=Take[PadRight[If[ColorQ[clr],{clr},clr],Length[newiter],clr],Length[newiter]];
		style=MapThread[{#1,If[Head[#2]===Symbol,#2,PointSize[#2]]}&,{clr,ptsize}];
	
		plts=MapThread[ListPlot[#1,PlotRange->All,Ticks->#2,Background->#3,Joined->#4,PlotStyle->#5,ImageSize->#6]&,{data,tix,back,joined,style,imgsize}];
		Return[If[pstyle==={},plts,pstyle[plts]]];
	];
	
	plts=MapThread[ImagePlot[#1,ImageSize->#2,Scaling->#3,ChannelColor->#4,Border->#5,BorderColor->#6,PlotTogether->together]&,{data,imgsize,scaling,chlclr,bdr,bdrclr}];
	f[x_]:=If[Length[x]==3,If[pstyle===GraphicsRow,GraphicsColumn[x],GraphicsRow[x]],x];
	Return[If[pstyle==={},plts,pstyle[Map[f,plts]]]];
];

(* Error messages *)

MatrixStretch::badinput="The input must be a matrix - MatrixStretch failed."
MatrixStretch::badrange="The value for IntensityRange must be a list of two numbers with the first not greater than the second - MatrixStretch failed."
ImagePlot::badinput="The input for ImagePlot is numeric and must be a matrix or a list of three matrices with equal dimensions - ImagePlot failed."
WaveletPlot::badinput="The input for WaveletPlot is numeric and must be a matrix or a list of three matrices with equal dimensions - WaveletPlot failed."
WaveletPlot::baditerations="Warning :: The value for NumIterations, due to the length/dimensions of the input, must be a nonnegative integer less than or equal to `1` - resetting the value to 0."
WaveletPlot::noiterations="The value {} is not valid for Iteration - WaveletPlot failed."
WaveletPlot::baditeration="Warning :: At least one value in Iteration is not a valid portion of the wavelet transform - resetting Iteration to All (Default)."
WaveletPlot::baddimmingrange="Warning :: DimmingRange must be a vector of length 2, sorted small to large, whose elements are integers in the range 0,...,255  - resetting DimmingRange to its default value."
WaveletPlot::plottogether="Warning :: Either the input trees or values for Iteration are incompatible for creating a color plot - PlotTogether reset to False.  Perhaps try reordering iteration elements."
WaveletVectorPlot::badinput="The input for WaveletVectorPlot is numeric and must be a vector - WaveletVectorPlot failed."
WaveletVectorPlot::badtree="The tree must be a list whose first element is 0 or 1 and the subsequent elements are vectors of length 2^k, k=1,2,... whose entries are 0 or 1 - WaveletVectorPlot failed."
WaveletVectorPlot::baditeration="Warning :: At least one value in Iteration is not a valid portion of the wavelet transform - resetting Iteration to All (Default)."
WaveletVectorPlot::badcolor="Warning :: The value for `1` must be a valid Mathematica color - resetting `1` to its default value."
FullWaveletVectorPlot::badinput="The input for FullWaveletVectorPlot is numeric and must be a list of vectors of equal lengths - FullWaveletVectorPlot failed."
FullWaveletVectorPlot::baditerations="The length of the input vectors are not of the appropriate size to plot - FullWaveletVectorPlot failed."
FullWaveletVectorPlot::badpresentation="The value for PresentationStyle must be {} (Default), GraphicsColumn, GraphicsRow or FlipView - resetting PresentationStyle to {}."
FullWaveletVectorPlot::badvalue="Warning :: The value provided for `1` is not of the correct form for use with FullWaveletVectorPlot - resetting the value for `1` to its default value."
FullWaveletPlot::badinput="The input for FullWaveletPlot is numeric and must be a list of vectors of equal lengths - FullWaveletPlot failed."
FullWaveletPlot::baditerations="Warning :: The value for NumIterations, due to the length/dimensions of the input, must be a nonnegative integer less than or equal to `1` - resetting the value to 0."
FullWaveletPlot::badpresentation="Warning :: The value for PresentationStyle must be {} (Default), GraphicsColumn, GraphicsRow or FlipView - resetting PresentationStyle to {}."
FullWaveletPlot::baditeration="Either the length of the list given for Iteration is of the wrong length or a particular iteration is not valid - FullWaveletPlot failed."
FullWaveletPlot::badvalue="Warning :: The value provided for `1` is not of the correct form for use with FullWaveletVectorPlot - resetting the value for `1` to its default value."
ShowBestBasis::badvalues="The input tree values must be either 0 or 1 - ShowBestBasis failed."
ShowBestBasis::badinput="The input does not match the format of the output provided by BestBasisTree - ShowBestBasis failed."
ShowBestBasis::badcolor="Warning :: The value for `1` is not a valid color value - resetting `1` to its default value."
ShowBestBasis::badimagesize="Warning :: The value for ImageSize must be either Automatic (default) or a positive integer - resetting ImageSize to Autmomatic."
ShowBestBasis::badopacity="Warning :: The value for `1` is not a valid value for Opacity - resetting `1` to its default value."
WaveletRegionPlot::badpresentation="The value for PresentationStyle must be {} (Default), GraphicsColumn, GraphicsRow or FlipView - resetting PresentationStyle to {}."
WaveletRegionPlot::badregions="The list of regions to be plotted together are incompatible - each triple should be of the form {{1,i,j,k},{2,i,j,k},{3,i,j,k}} - WaveletRegionPlot failed."
WaveletRegionPlot::badvalue="Warning :: The value provided for `1` is not of the correct form for use with WaveletRegionPlot - resetting the value for `1` to its default value."
End[]
EndPackage[]


