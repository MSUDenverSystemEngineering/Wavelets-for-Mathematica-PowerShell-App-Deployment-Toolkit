(* Mathematica package *)

BeginPackage["WaveletWare`PacketTransforms`",{"WaveletWare`CommonUsage`","WaveletWare`MiscFunctions`","WaveletWare`Filters`","WaveletWare`OrthogonalTransforms`","WaveletWare`BiorthogonalTransforms`"}]

(* Exported symbols added here with SymbolName::usage *)

(* Packet transform functions *)

WPTFull::usage="WPTFull[data,filter,opts] takes a vector, matrix or a list of three matrices of equal dimension, an orthogonal lowpass filter or biorthogonal filter pair, and returns the (biorthogonal) wavelet packet transform for iterations 0,1,2,...."
BestBasisTree::usage="BestBasisTree[data,opts] takes data generated by WPTFull returns the tree for the best basis to be used with the wavelet packet transform."
WPT::usage="WPT[data,filter,opts] computes the wavelet packet transform of a vector, a matrix or a list of three matrices, returning the transform and the packet tree."
InverseWPT::usage="InverseWPT[{wt,tree},h,opts] computes the inverse wavelet packet transform of a vector, a matrix or a list of three matrices."
FBIPacketTransform::usage="FBIPacketTransform[data] computes the wavelet packet transform or a matrix or list of three matrices using the FBI best basis tree."
InverseFBIPacketTransform::usage="InverseFBIPacketTransform[wt] computes the inverse wavelet packet transform of the inpt matrix or list of three matrices."
FBITree::usage="FBITree[] is the best basis tree used by the FBI Wavelet Scalar Quantization method."
FBIPacketMatrixToList::usage="FBIPacketMatrixToList[a] separates the output of the FBIPacketTransform into a list of 64 bands (matrices)."
FBIPacketListToMatrix::usage="FBIPacketListToMatrix[list] reconstructs the FBI packet transform matrix from a list of its 64 bands (matrices)."
FBIBinWidths::usage="FBIBinWidths[lst,rate] constructs the bin widths for quantization given the list of bands from the packet transform and a bit rate."
FBIQuantizer::usage="FBIQuantizer[a,z,q] applies the FBI quantizing function to matrix a.  The bin width is q and z is the zero bin width."
FBIDeQuantizer::usage="FBIDeQuantizer[a,z,q] applies the FBI dequantizing function to matrix a.  The bin width is q and z is the zero bin width."
ShannonEntropy::usage="ShannonEntropy[data] is a cost function that can be used in conjunction with wavelet packet transforms."
NumberAboveThreshold::usage="NumberAboveThreshold[data,p] is a cost function that can be used in conjunction with wavelet packet transforms."
NumberNonzero::usage="NumberNonzero[data] is a cost function that can be used in conjunction with wavelet packet transforms."
SumOfPowers::usage="SumOfPowers[data,p] is a cost function that can be used in conjunction with wavelet packet transforms."

(* Option Values for packet transforms *)

FixedTree::usage="FixedTree is an option for WPT that directs WPT to used a fixed basis tree rather than generate a best basis tree."
SecondParameter::usage="SecondParameter is an option for BestBasisTree and WPT that allows a user to input a cost function that has a second parameter."
CostFunction::usage="CostFunction is an option that allows the cost function to be set to something different than NumberNonzero (default) in BestBasisTree and WPT."
Printq::usage="Printq is an option for FBIBinWidths that, when set to True, prints the constant of proportion q."

(* Options for orthogonal transform functions *)

Options[WPTFull]={NumIterations->1,Shift->0,Boundary->False,IntegerMap->False,Computation->Numerical};
Options[BestBasisTree]={SecondParameter->None,CostFunction->NumberNonzero};
Options[WPT]=Join[Options[WPTFull],Options[BestBasisTree],{CompositeTree->False,FixedTree->{}}];
Options[InverseWPT]={Shift->0,Boundary->False,IntegerMap->False,Computation->Numerical};
Options[FBIBinWidths]={Printq->False};

Begin["`Private`"]
(* Implementation of the package *)

(* Packet transform functions *)

WPTFull[v_,h_,OptionsPattern[]]:=Module[{datatype,maxits,its,offset,boundary,intmap,comp,wt,f},
	(* Check the validity of the data *)
	{datatype,maxits}=CheckData[v];
	If[!MemberQ[{1,2,3},datatype],Message[WPTFull::"badinput"];Return[{}]];
	
	(* Check the validity of the filter.  1 = orthogonal filter, 2 = biorthogonal filter *)
	If[!MemberQ[{1,2},CheckFilter[h]],Message[WPTFull::"badfilter"];Return[{}];];
	
	(* Get options and check integrity *)
	{its,offset,boundary,intmap,comp}=OptionValue[WPTFull,{NumIterations,Shift,Boundary,IntegerMap,Computation}];
	{boundary,intmap}=Map[TrueFalse,{boundary,intmap}];
	If[!CheckIterations[its,maxits],Message[WPTFull::"baditerations",maxits];its=0;];
	If[!IntegerQ[offset],Message[WPTFull::"badvalue","Shift",offset];offset=0;];
	
	(* Check that the filter size, iterations and the length of the data are compatible for doing the transform *)
	If[!CheckDataFilterSize[datatype,v,its,h],Message[WPTFull::"badsizes"];Return[{}]];
	
	(* Make a generic wavelet transform function *)
	wt[t_]:=Which[
		N[h]==={.5,.5},HWT[t,Shift->offset,Computation->comp,Orthogonal->False],
		h==={1,1}/Sqrt[2],HWT[t,Shift->offset,Computation->comp,Orthogonal->True],
		h===LeGall[],LWT[t,IntegerMap->intmap,Computation->comp],
		VectorQ[h],WT[t,h,Shift->offset,Computation->comp],
		True,BWT[t,h,Boundary->boundary,Computation->comp]
	];
	
	(* Do the vector case first *)
	
	If[datatype==1,
		f[{x_,i_}]:=Module[{d,n=Length[First[x]]},
			d=Partition[Last[x],n/2^(i-1)];
			Return[{Append[x,Flatten[Map[wt,d]]],i+1}];
		];
		
		Return[First[Nest[f,{{v},1},its]]];
	];
	
	(* A useful function for computing WPTFull on a matrix *)
	
	f[m_]:=Module[{r},
		
		r[{x_,i_}]:=Module[{d,n=Dimensions[First[x]]},
			d=Partition[Last[x],n/2^(i-1)];
			Return[{Append[x,ArrayFlatten[Map[wt,d,{2}]]],i+1}];
		];
		
		Return[First[Nest[r,{{m},1},its]]];
	];
	
	If[datatype==2,Return[f[v]],Return[Transpose[Map[f,v]]]];
];

BestBasisTree[data_,OptionsPattern[]]:=Module[{d,datatype,maxits,its,fct,param,CostF,g},
	d=Map[CheckData,data];
	
	If[AllTrue[d,#==First[d]&],{datatype,maxits}=First[d],Message[BestBasisTree::"badinput"];Return[{}]];
	
	its=Length[d]-1;
	
	(* Get the cost function *)
	fct=OptionValue[BestBasisTree,CostFunction];
	
	(* Get the optional parameter, if there is one *)
	param=OptionValue[BestBasisTree,SecondParameter];
	If[param===None,CostF[x_]:=fct[x],CostF[x_]:=fct[x,param]];
	
	(* A function to do the updating for a vector or a matrix *)
	g[x_]:=Module[{y,tree,cost,k,update},
		
		(* An updating function *)
		update[{t_,c_,i_}]:=Module[{inputcost,nextcost,nexttree,tmp,updatedtree},
			inputcost=If[datatype==1,
							Map[Total,Partition[c,2]],
							Partition[Map[Total[Flatten[#],{1}]&,Flatten[Partition[c,{2, 2}],1]],2^i]
						];
			nextcost=Map[CostF,y[[i]],{datatype}];
			nexttree=Boole[Map[NonNegative,inputcost-nextcost,{datatype}]];
			nextcost=nexttree*nextcost+(1-nexttree)*inputcost;
			tmp=If[datatype==1,
					MapThread[Partition[#1,#2]&,{t,2^Range[Length[t]]}],
					MapThread[Partition[#1,{#2,#2}]&,{t,2^Range[Length[t]]}]
				];
			updatedtree=If[datatype==1,
							Prepend[Map[Flatten,Map[((1-nexttree)*#)&,tmp]],nexttree],
							Prepend[Map[ArrayFlatten,Map[((1-nexttree)*#)&,tmp]],nexttree]
						];
			Return[{updatedtree,nextcost,i-1}];
		];
		
		(* Load up initial values *)
		y=If[datatype==1,
			MapThread[Partition[#1,Length[First[x]]/#2]&,{Rest[x],2^Range[its]}],
			MapThread[Partition[#1,Dimensions[First[x]]/#2]&,{Rest[x],2^Range[its]}]
			];
		{tree,cost}=If[datatype==1,
			{{ConstantArray[1, 2^its]},Map[CostF, Last[y]]},
			{{ConstantArray[1,2^its*{1,1}]},Map[CostF, Last[y], {2}]}
			];
		
		(* Create the tree using update *)
		{tree,cost,k}=Nest[update,{tree,cost,its-1},its-1];
		
		If[Total[Flatten[cost]]<CostF[First[data]],
 			Return[Prepend[tree, 0]],
 			If[datatype==1,
 				Return[Prepend[Table[ConstantArray[0,2^k],{k,1,its}],1]],
 				Return[Prepend[Table[ConstantArray[0,2^k*{1,1}],{k,1,its}],1]]
 			];
		];
	];
	
	If[datatype<3,
		Return[g[data]],
		datatype=2; (* The update function expects a matrix if we are here *)
		Return[Map[g,Transpose[data]]];
	];
];

WPT[data_,h_,OptionsPattern[]]:=Module[{datatype,maxits,dim,its,fixedtree,offset,boundary,intmap,comp,param,f,comptree,y,tmp,tree,wt,mask},
	(* Check data integrity*)
	{datatype,maxits}=CheckData[data];
	If[!MemberQ[{1,2,3},datatype],Message[WPT::"badinput"];Return[{}]];
	dim=Which[datatype==1,Length[data],datatype==2,Dimensions[data],True,Dimensions[First[data]]];
	
	(* Check the validity of the filter.  1 = orthogonal filter, 2 = biorthogonal filter *)
	If[!MemberQ[{1,2},CheckFilter[h]],Message[WPT::"badfilter"];Return[{}];];
	
	(* Get options and check integrity *)
	
	its=OptionValue[WPT,NumIterations];
	If[!CheckIterations[its,maxits],Message[WPT::"baditerations",maxits];its=0;];
	
	(* Get the CompositeTree value *)
	comptree=TrueFalse[OptionValue[WPT,CompositeTree]];
	
	(* See if someone entered its=0 *)
	If[its==0,If[datatype<3||comptree,Return[{data,{1}}],Return[{data,{{1},{1},{1}}}]]];
	
	(* Check that the filter size, iterations and the length of the data are compatible for doing the transform *)
	If[!CheckDataFilterSize[datatype,data,its,h],Message[WPT::"badsizes"];Return[{}]];
	
	(* Compute the full packet transform *)
	{offset,boundary,intmap,comp}=OptionValue[WPT,{Shift,Boundary,IntegerMap,Computation}];
	{boundary,intmap}=Map[TrueFalse,{boundary,intmap}];
	y=WPTFull[data,h,NumIterations->its,Shift->offset,Boundary->boundary,IntegerMap->intmap,Computation->comp];

	(* Now get/create the tree *)
	
	(* Get the FixedTree and CompositeTree options *)
	fixedtree=OptionValue[WPT,FixedTree];
			
	(* Using a cost function *)
	If[fixedtree==={},
		(* Get cost function option values and CompositeTree value *)
		{param,f}=OptionValue[WPT,{SecondParameter,CostFunction}];
		tmp=If[comptree&&datatype==3,Mean[Transpose[y]],y];
		tree=BestBasisTree[tmp,CostFunction->f,SecondParameter->param];
	];
	
	(* User provides the tree *)
	If[fixedtree!={},
		its=If[datatype==3&&comptree,CheckTree[fixedtree,2],CheckTree[fixedtree,datatype]];
		If[its===False,Message[WPT::"badtree"];Return[{}];];
		If[!CheckIterations[its,maxits],Message[WPT::"baditerations",maxits];Return[{data,{1}}];];
		tree=fixedtree;
	];
	
	(* Use y and tree to compute the transform *)
	
	(* 1D case first *)
	If[datatype==1,
		tmp = Prepend[MapThread[Partition[#1,dim/#2]&,{Rest[y],2^Range[its]}],First[y]];
		wt=Total[Map[Flatten,MapThread[(#1*#2)&,{tmp,tree}]]];
		Return[{wt,tree}];
	];
	
	(* 
	A useful function for finishing off the packet transform.  Basically for each level in yy, it multiplies portions by 1 or 0 based on whether or not the region is part of the best basis.
	 *)
	mask[yy_,tr_]:=Module[{s,fct},
		s=MapThread[Partition[#1,dim/#2]&,{Rest[yy],2^Range[its]}];
		fct[a_,b_]:=MapThread[(#1*#2)&,{a,b},2];
		Return[Total[Prepend[Map[ArrayFlatten,MapThread[fct,{s,Rest[tr]}]],First[yy]*First[tr]]]];
	];
	
	(* Grayscale image next *)
	If[datatype==2,
		Return[{mask[y,tree],tree}];
	];
	
	(* Now handle color images *)
	If[datatype==3,
		If[comptree,
			wt=Map[mask[#,tree]&,Transpose[y]];
			Return[{wt,tree}],
			wt=MapThread[mask[#1,#2]&,{Transpose[y],tree}];
			Return[{wt,tree}];
			];
	];
];

InverseWPT[{wt_,tree_},h_,OptionsPattern[]]:=Module[{datatype,maxits,dim,comptree,its,offset,boundary,intmap,comp,inv,r,f,tmp},
	(* Check data integrity*)
	{datatype,maxits}=CheckData[wt];
	If[!MemberQ[{1,2,3},datatype],Message[InverseWPT::"badinput"];Return[{}]];
	dim=Which[datatype==1,Length[wt],datatype==2,Dimensions[wt],True,Dimensions[First[wt]]];
	
	(* Check the validity of the filter.  1 = orthogonal filter, 2 = biorthogonal filter *)
	If[!MemberQ[{1,2},CheckFilter[h]],Message[InverseWPT::"badfilter"];Return[{}];];

	(*comptree=TrueFalse[OptionValue[InverseWPT,CompositeTree]];*)
	comptree=datatype==3&&IntegerQ[CheckTree[tree,2]];
	
	its=If[datatype==3&&comptree,CheckTree[tree,2],CheckTree[tree,datatype]];
	If[its==False,Message[InverseWPT::"badtree"];Return[{}];];
	
	If[!CheckIterations[its,maxits],Message[InverseWPT::"baditerations",maxits];its=0;];
	
	(* See if someone entered its=0 *)
	If[its==0,Return[wt]];
	
	(* Check that the filter size, iterations and the length of the data are compatible for doing the transform *)
	If[!CheckDataFilterSize[datatype,wt,its,h],Message[InverseWPT::"badsizes"];Return[{}]];
	
	(* Now reverse the tree *)
	r=Which[datatype<=2,Reverse[tree],comptree,ConstantArray[Reverse[tree],3],True,Map[Reverse,tree]];
	
	(* Get the transform options *)
	{offset,boundary,intmap,comp}=OptionValue[InverseWPT,{Shift,Boundary,IntegerMap,Computation}];
	{boundary,intmap}=Map[TrueFalse,{boundary,intmap}];
	
	(* Create an inverse wavelet transform based on the input parameters *)
	inv[t_]:=Which[
		h===Haar[],
			InverseHWT[t,Shift->offset,Computation->comp,Orthogonal->True],
		N[h]==={.5,.5},
			InverseHWT[t,Shift->offset,Computation->comp,Orthogonal->False],
		VectorQ[h],
			InverseWT[t,h,Shift->offset,Computation->comp],
		h===LeGall[],
			InverseLWT[t,IntegerMap->intmap,Computation->comp],
		AllTrue[h,VectorQ]&&Length[h]==2,
			InverseBWT[t,h,Computation->comp,Boundary->boundary]
	];

	(* Define the iteration function *)
	f[{d_,i_,p_,t_}]:=Module[{indicator,data},
		indicator=If[VectorQ[d],Map[Mean,Partition[i,2]],Map[Mean[Flatten[#]]&,Partition[i,{2,2}],{2}]];
		data=If[VectorQ[d],
			Flatten[MapThread[If[#1==1,inv[#2],#2]&,{indicator,Partition[d, Length[d]/2^(its-p)]}]],
			ArrayFlatten[MapThread[If[#1==1,inv[#2],#2]&,{indicator,Partition[d, Dimensions[d]/2^(its-p)]},2]]
		];
		Return[{data,indicator+t[[p+1]],p+1,t}];
	];
	
	(* Apply the iteration function *)
	If[datatype<=2,
		tmp=Nest[f,{wt,First[r],1,r},Length[tree]-1];
		Return[First[tmp]],
		tmp=MapThread[Nest[f,{#1,First[#2],1,#2},Length[#2]-1]&,{wt,r}];
		Return[Map[First,tmp]];
	];
];	

FBIPacketTransform[data_]:=First[WPT[data,Reverse[CDF97[]],NumIterations->5,CompositeTree->True,FixedTree->FBITree[],Computation->Numerical,Boundary->True]];

InverseFBIPacketTransform[data_]:=InverseWPT[{data,FBITree[]},Reverse[CDF97[]],Computation->Numerical,Boundary->True];

FBITree[]:=Module[{one=ConstantArray[1,{4,4}],zero=ConstantArray[0,{4,4}],m16,m32},
	m16=ArrayFlatten[{{one,one,zero,zero},{one,zero,zero,zero},ConstantArray[zero,4],ConstantArray[zero,4]}];
	m16=ReplacePart[m16,{1,1}->0];
	m32=ConstantArray[0,{32,32}];
	m32=ReplacePart[m32,{{1,1}->1,{2,1}->1,{1,2}->1,{2,2}->1}];
	Return[{0,{{0,0},{0,0}},{{0,0,1,1},{0,1,1,1},{1,1,1,1},{1,1,1,1}},ConstantArray[0,{8,8}],m16,m32}];
];

FBIPacketMatrixToList[a_]:=Module[{r,c,b2,r1,r2,r3,r4,f,b4,b5},
	If[!MatrixQ[a],Message[FBIPacketMatrixToList::"badinput"];Return[{}]];
	If[MaxIts[a]<5,Message[InverseWPT::"badinput"];Return[{}]];
   	{r,c}=Dimensions[a];
   
   	(* Do the big blocks first *)
   	b2=Drop[Drop[Apply[Join,Partition[a,{r,c}/4]],2],{3}];
   	{r1,r2,r3,r4}=Map[Take[b2,#]&,{{1,3},{4,7},{8,11},{12,13}}];
   	b2=Apply[Join,{RotateRight[r1],r2,RotateRight[r3,2],r4}];
   
   	(* A function to line up the 2^4 level bands *)
   	f[lst_]:=Module[{a1,a2,a3,a4,a5},
   		{a1,a2,a3,a4,a5}=Map[Take[lst,#]&,{{1,2},{3,6},{7,10},{11,14},{15,16}}];
     	Return[Apply[Join,{a1,RotateRight[a2,2],a3,RotateRight[a4,2],a5}]];
     ];
   
   	{r1,r2,r3}=MapThread[Take[a,#1,#2]&,{{{1,r/4},{1,r/4},{r/4+1,r/2}},{{1,c/4},{c/4+1,c/2},{1,c/4}}}];
   	{r1,r2,r3}=Map[Apply[Join,Partition[#,{r,c}/16]]&,{r1,r2,r3}];
   	b5=Apply[Join,Partition[First[r1],{r,c}/32]];
   	b4=Rest[Apply[Join,Map[f,{r1,r2,r3}]]];
   	Return[Apply[Join,{b5,b4,b2}]];
];

FBIPacketListToMatrix[lst_]:=Module[{x,d,lvl4,a1,a2,a3,f,lvl2},
	If[!(Length[lst]==64 && AllTrue[lst,MatrixQ]),Message[FBIPacketListToMatrix::"badinput"];Return[{}]];
	d=Dimensions[First[lst]];
	x=Apply[Join,{ConstantArray[d,4],ConstantArray[2*d,47],ConstantArray[8*d,13]}];
	If[Map[Dimensions,lst]!=x,Message[FBIPacketListToMatrix::"badinput"];Return[{}]];
	
	
   	x=ArrayFlatten[Partition[Take[lst,4],2]];
   	lvl4 = Prepend[Take[lst,{5,51}],x];
   	{a1,a2,a3}=Partition[lvl4,16];
   
   	(* This function takes lists of 16 matrices and puts them together in the right way *)
   	f[t_]:=ArrayFlatten[Partition[Map[ArrayFlatten[Partition[#,2]]&,Partition[t,4]],2]];
   
   	x=Map[f,{a1,a2,a3}];
   	lvl2=Join[x,Take[lst,{52,64}]];
   	Return[f[lvl2]];
];

FBIBinWidths[lst_,r_,OptionsPattern[]]:=Module[{d,y,A,m,S,fsigma,sigma,P,q,z,pq},
	If[r<=0,Message[FBIBinWidths::"badbitrate"];Return[{}]];
	If[!(Length[lst]==64 && AllTrue[lst,MatrixQ]),Message[FBIBinWidths::"badinput"];Return[{}]];
	d=Dimensions[First[lst]];
	y=Apply[Join,{ConstantArray[d,4],ConstantArray[2*d,47],ConstantArray[8*d,13]}];
	If[Map[Dimensions,lst]!=y,Message[FBIBinWidths::"badinput"];Return[{}]];

	A=Join[ConstantArray[1,52],{1.32,1.08,1.42,1.08,1.32,1.42,1.08,1.08}];
   	m=Apply[Join,{{1024,1024,1024,1024},ConstantArray[256,47],ConstantArray[16,9]}];
   	S=Total[1/m];
   
   	fsigma[a_]:=Module[{rows,cols,mk,nk,i0,j0,x},
    	{rows,cols}=Dimensions[a];
     	{mk,nk,i0,j0}=Floor[{7*rows/16,3*cols/4,9*rows/32,cols/8}];
     	x=(Take[a,{i0,i0+mk-1},{j0,j0+nk-1}]-Mean[Flatten[a]])^2;
     	Return[Total[Flatten[x]]/(mk*nk-1)];
    ];
   
   	sigma=Map[fsigma,Drop[lst,-4]];
   	P=Join[{1,1,1,1},MapThread[10/(#1*Log[#2])&,{Drop[A,4],Drop[sigma,4]}]];
   	z=Apply[Times,(Sqrt[sigma]/P)^(1/m)]^(-1/S);
   	q=(0.4)*2^(r/S-1)*z;
   	pq=TrueFalse[OptionValue[FBIBinWidths,Printq]];
	If[pq,Print["The value for q is ",q,"."]];
   	
   	P=MapThread[Which[#1<1.01,0,#2/#1/q>=5,0,True,#2]&,{sigma,P}];
   	Return[Join[P/q,{0,0,0,0}]];
];

FBIQuantizer[a_,z_,q_]:=Which[q==0,0,a>z/2,Floor[(a-z/2)/q]+1,a<-z/2,Ceiling[(a+z/2)/q]-1,True,0];
SetAttributes[FBIQuantizer, Listable];

FBIDeQuantizer[p_,z_,q_,c_]:=Which[p>0,(p-c)*q+z/2,p<0,(p+c)*q-z/2,True,0];
SetAttributes[FBIDeQuantizer, Listable];

ShannonEntropy[z__]:=Module[{x,ln},
	If[Length[{z}]!=1,Message[ShannonEntropy::"badarguments"];Return[{}];];
	x=N[Flatten[z]];
	If[!VectorQ[x,NumericQ],Message[ShannonEntropy::"badinput"];Return[{}];];
	If[AllTrue[x,(#==0&)],Return[0]];
	x=N[x/Norm[x]];
	ln=Map[Which[#!=0,Log[#^2],True,0]&,x];
	Return[-ln.x^2];
];

NumberAboveThreshold[z__]:=Module[{x,t},
	If[Length[{z}]!=2,Message[NumberAboveThreshold::"badarguments"];Return[{}];];
	{x,t}={Flatten[First[{z}]],Last[{z}]};
	If[!VectorQ[x,NumericQ],Message[NumberAboveThreshold::"badinput"];Return[{}];];
	If[!(NumericQ[t]&&t>0),Message[NumberAboveThreshold::"badtolerance"];Return[{}];];
	Return[Length[Select[x,(Abs[#]>=t)&]]];
];

NumberNonzero[z__]:=Module[{x},
	If[Length[{z}]!=1,Message[NumberNonzero::"badarguments"];Return[{}];];
	x=Flatten[z];
	If[!VectorQ[x,NumericQ],Message[NumberNonzero::"badinput"];Return[{}];];
	Return[Length[Select[x,(#!=0)&]]];
];

SumOfPowers[z__]:=Module[{x,p},
	If[Length[{z}]!=2,Message[SumOfPowers::"badarguments"];Return[{}];];
	{x,p}=N[{Flatten[First[{z}]],Last[{z}]}];
	If[!VectorQ[x,NumericQ],Message[SumOfPowers::"badinput"];Return[{}];];
	If[!(NumericQ[p]&&p>0),Message[SumOfPowers::"badpower"];Return[{}];];
	Return[Total[Abs[N[x]]^N[p]]];
];


(* Error messages *)

WPTFull::badinput="The input for WTFull is numeric and must be a vector, matrix or a list of three matrices with equal dimensions - WPTFull failed."
WPTFull::badfilter="The input filter must be an orthogonal lowpass filter of even length - WPTFull failed."
WPTFull::baditerations="Warning :: The value for NumIterations, due to the length/dimensions of the input, must be a nonnegative integer less than or equal to `1` - resetting the value to 0."
WPTFull::badvalue="Warning :: The value `2` for `1` is not an integer - resetting `1` = 0." 
WPTFull::badsizes="Either the length/dimensions of the input data are not of the appropriate size or the length of the filter(s) are too large for the number of iterations requested  - WPTFull failed."
WPT::badinput="The input for WPT is numeric and must be a vector, matrix or a list of three matrices with equal dimensions - WPT failed."
WPT::badfilter="The input filter must be an orthogonal lowpass filter of even length - WPT failed."
WPT::baditerations="Warning :: The value for NumIterations, due to the length/dimensions of the input, must be a nonnegative integer less than or equal to `1` - resetting the value to 0."
WPT::badsizes="Either the length/dimensions of the input data are not of the appropriate size or the length of the filter(s) are too large for the number of iterations requested  - WPT failed."
WPT::badtree="The tree must be a list (or three lists) whose first element is 0 or 1 and the subsequent elements are matrices of size 2^k, k=1,2,... whose entries are 0 or 1 - WPT failed."
InverseWPT::badinput="The input for InverseWPT is numeric and must be a vector, matrix or a list of three matrices with equal dimensions - InverseWPT failed."
InverseWPT::badfilter="The input filter must be an orthogonal lowpass filter of even length - InverseWPT failed."
InverseWPT::baditerations="Warning :: The value for NumIterations, due to the length/dimensions of the input, must be a nonnegative integer less than or equal to `1` - resetting the value to 0."
InverseWPT::badsizes="Either the length/dimensions of the input data are not of the appropriate size or the length of the filter(s) are too large for the number of iterations requested  - InverseWPT failed."
InverseWPT::badtree="The tree must be a list (or three lists) whose first element is 0 or 1 and the subsequent elements are matrices of size 2^k, k=1,2,... whose entries are 0 or 1 - InverseWPT failed."
BestBasisTree::badinput="The input for WTFull is numeric and must be a vector, matrix or a list of three matrices with equal dimensions - BestBasisTree failed."
FBIPacketMatrixToList::badinput="The input must be a matrix whose dimensions are divisible by 32 - FBIPacketMatrixToList failed."
FBIPacketListToMatrix::badinput="The input must be a list of 64 matrices, the first 4 of the same dimensions, the next 47 twice those dimensions, and the last 13 eight times those dimensions - FBIPacketMatrixToList failed."
FBIBinWidths::badbitrate="The bit rate must be a positive number - FBIBinWidths failed."
FBIBinWidths::badinput="The input must be a list of 64 matrices, the first 4 of the same dimensions, the next 47 twice those dimensions, and the last 13 eight times those dimensions - FBIBinWidths failed."
(*
WaveletTree::baditeration="The value for this argument must be a nonnegative integer - WaveletTree failed."
WaveletTree::baddimension="The value of InputDimension must be either 1 (for a vector) or 2 (for a matrix) - WaveletTree failed."
*)
ShannonEntropy::badinput="The input must be a vector or matrix of numerical values - ShannonEntropy failed."
ShannonEntropy::badarguments"The number of arguments for this function is 1 - ShannonEntropy failed."
NumberAboveThreshold::badinput="The input must be a vector or matrix of numerical values - NumberAboveThreshold failed."
NumberAboveThreshold::badtolerance="The tolerance must be a positive number - NumberAboveThreshold failed."
NumberAboveThreshold::badarguments"The number of arguments for this function is 2 - NumberAboveThreshold failed."
NumberNonzero::badinput="The input must be a vector or matrix of numerical values - NumberNonzero failed."
NumberNonzero::badarguments"The number of arguments for this function is 1 - NumberNonzero failed."
SumOfPowers::badinput="The input must be a vector or matrix of numerical values - SumOfPowers failed."
SumOfPowers::badpower="The power must be a positive number - SumOfPowers failed."
SumOfPowers::badarguments"The number of arguments for this function is 2 - SumOfPowers failed."

End[]
EndPackage[]