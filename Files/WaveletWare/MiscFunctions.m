(* Mathematica package *)

BeginPackage["WaveletWare`MiscFunctions`",{"WaveletWare`CommonUsage`"}]

(* Exported symbols added here with SymbolName::usage *)
Cs::usage="Cs[w] is the same as the Mathematica syntax TrigToExp[Cos[w]]."
Sn::usage="Sn[w] is the same as the Mathematica syntax TrigToExp[Sin[w]]."
FiniteFourier::usage="FiniteFourier[w,h,offset] takes an independent variable w, a coefficient list h, and a starting index i and returns a finite-length Fourier series."
PutCorner::usage="PutCorner[a,b] overwrites the top left corner of the first matrix input with the second matrix input."
GetCorner::usage="GetCorner[a,{r,c}] extracts a submatrix from upper left corner of a of dimension r x c."
ChopVector::usage="ChopVector[v,pow] takes a vector and a power of two pow and returns a vector whose length is divisible by 2^pow." 
DataFormats::usage="DataFormats is a WaveletWare package variable that is a list of the Mathematica tabular text and spreadsheet formats."
DataInfo::usage="DataInfo[opts] returns the absolute path name for each tabular text or spreadsheet in the WaveletWare package.  It can also supply information about the files."
PackageDirectory::usage="PackageDirectory[opts] returns the directory housing the package files (default), images, audio files, or data files included with the WaveletWare package."
WaveletMatrix::usage="WaveletMatrix[h,{r,c},opts] takes a filter (or biorthogonal filter pair) and generates a wavelet matrix of prescribed dimensions."
WaveletVectorToList::usage="WaveletVectorToList[v,opts] takes a vector and, based on the number of iterations, creates sublists of the various portions of the wavelet transform."
WaveletListToVector::usage="WaveletListToVector[list] takes a list of the different sublists of portions of the wavelet transform and returns a single list of values.  This command is equivalent to Flatten[list]."
WaveletMatrixToList::usage="WaveletMatrixToList[a,opts] takes a wavelet-transformed matrix and partitions it into a list that is of the form lowpass, list of nth highpass triple, ..., list of first highpass triple."
WaveletListToMatrix::usage="WaveletListToMatrix[lst,opts] takes a list generated by WaveletListToMatrix and returns a standard m x n matrix."
WaveletTree::usage="WaveletTree[its,opts] takes a number of iterations and generates the basis tree for a standard wavelet transform."
WaveletRegionList::usage="WaveletRegionList[tree] takes a wavelet packet tree or a list of three trees (for a color image) and returns a list of n-tuples (pairs, triples, 4-tuples for a vector, matrix, or list of three matrices, respectively) that correspond to the regions represented by the tree ."
WaveletRegionTake::usage="WaveletRegionTake[a,iter] or WaveletRegionTake[a,tree,iter] returns portions of the wavelet transforms as prescribed by the list of regions iter."
TrueFalse::usage="TrueFalse takes an argument and if it is True, returns True. Otherwise it returns False."
MaxIts::usage="MaxIts[v] takes as input a vector or matrix and returns the largest power of two that will divide the length or dimensions of the input."
CheckData::usage="CheckData[data] takes an input argument and determines whether it is a vector (1), matrix (2) or list of three matrices (3).  The routine also returns the maximum number of iterations of a wavelet transform that can be performed on the input."
CheckFilter::usage="CheckFilter[f] takes an input and determines whether it is an orthogonal filter (1), a biorthogonal filter (2) or not a filter (-1)."
CheckIterations::usage="CheckIterations[iter,max] takes iter and checks to see that it is a nonnegative integer less than or equal to max (an integer)."
CheckDataFilterSize::usage="CheckDataFilterSize[type,data,i,h] determines if the input data is of the correct length/dimensions so that i iterations of the wavelet transform using filter h can be applied to it."
CheckParity::usage="CheckParity[n] determines if a list of n positive integers are all odd (returns 1), all even (returns 2), or neither (returns 0)."
CheckTree::usage="CheckTree[tree,datatype] determines, given datatype, if an input tree is valid for use with a packet transform."
CheckIterationValue::usage="CheckIterationValue[iter,its,tree,datatype] checks the validity of a given value of Iteration."
CheckColor::usage="CheckColor[clr,datatype,together] determines if the input is a valid Mathematica color.  If so, it converts the input to RGB and returns the corresponding ordered triple." 

(* Option Values for MiscFunctions *)

DataType::usage="DataType is an option for PackageDirectory that specifies the directory for all package files (default), images, audio files, or data files."
Images::usage="Images is a symbol that represents a value of the DataType option of the PackageDirectory function in the WaveletWare package ."
Sounds::usage="Sounds is a symbol that represents a value of the DataType option of the PackageDirectory function in the WaveletWare package ."
Data::usage="Data is a symbol that represents a value of the DataType option of the PackageDirectory function in the WaveletWare package ."
MatrixBlock::usage="MatrixBlock is an option for WaveletMatrix that allows the user to determine the part (Lowpass, Highpass, All) of the matrix to construct."
Lowpass::usage="Lowpass is a symbol that represents a value of MatrixBlock in the WaveletMatrix routine in the WaveletWare package."
Highpass::usage="Highpass is a symbol that represents a value of MatrixBlock in the WaveletMatrix routine in the WaveletWare package"
InputDimension::usage="InputDimension is an option for WaveletTree that instructs the routine to make a tree for one-dimensional (default) or two-dimensional data."
ReturnIterationList::usage="ReturnIterationList is an option for WaveletRegionTake that when set to True (default is False), returns the list of regions that were extracted from the input data."

(* Function Options *)
Options[DataInfo]={DisplayInfo->False};
Options[PackageDirectory]={DataType->All};
Options[WaveletMatrix]={Shift->0,MatrixBlock->All};
Options[WaveletVectorToList]={NumIterations->1};
Options[WaveletMatrixToList]=Options[WaveletVectorToList];
Options[WaveletListToMatrix]=Options[WaveletVectorToList];
Options[WaveletTree]={InputDimension->1};
Options[WaveletRegionTake]={NumIterations->1,ReturnIterationList->False};

Begin["`Private`"]
(* Implementation of the package *)


Cs[w_]:=TrigToExp[Cos[w]];

Sn[w_]:=TrigToExp[Sin[w]];

FiniteFourier[w_,h_,i_:0]:=Module[{k},
	If[!IntegerQ[i],Message[FiniteFourier::"badindex"];Return[0]];
	Return[h.Table[E^(I*k*w),{k,i,i+Length[h]-1}]];
	];
	
PutCorner[a_,b_] := Module[{r,c,tmp=a},
   If[!MatrixQ[a] || !MatrixQ[b],Message[PutCorner::"badinput"];Return[{}]];
   
   If[AllTrue[Dimensions[a]-Dimensions[b],(#>=0)&],
		{r,c}=Dimensions[b];
   		tmp[[1 ;; r, 1 ;; c]] = b;
   		Return[tmp],
   		Message[PutCorner::"baddimensions"];
   		Return[a];
	];
   ];
   
GetCorner[a_,{r_,c_}]:=Module[{},
   If[!MatrixQ[a],Message[GetCorner::"badinput"];Return[{}]];
   If[!AllTrue[{r, c}, IntegerQ],Message[GetCorner::"nonintegers",r,c];Return[a]];
   
   If[AllTrue[Dimensions[a]-{r,c},(#>=0)&],
    	Return[Take[a,{1,r},{1,c}]],
    	Message[GetCorner::"baddimensions",r,c];
    	Return[a];
   ];
];


ChopVector[v_,pt_]:=Module[{n},
	If[!VectorQ[v],Message[ChopVector::"badinput"];Return[{}]];
	If[!(IntegerQ[pt]&&pt>=0),Message[ChopVector::"badpower"];Return[{}]];
	
	n=Length[v];
	If[2^pt>n,Message[ChopVector::"badlength",n,2^pt];Return[v]];
	
	Return[Drop[v,-Mod[n,2^pt]]];
];

ChopVector[v_]:=ChopVector[v,0];

DataFormats={"Table","CSV","TSV","XLS","XLSX","ODS","SXC","DIF"};

DataInfo[OptionsPattern[]]:=Module[{HomeDirectory=Directory[],DataDirectory,files,filenames,type},
	
	(* First find package directory *)
	(*
	WaveletWareFile=Complement[Map[FindFile[#<>"WaveletWare.m"]&,Map[StringJoin[#,"/WaveletWare/"]&,$Path]],{$Failed}];
	If[Length[WaveletWareFile]==0,Message[DataInfo::"packagenotfound"];Return[{}]];
	PackageDirectory=DirectoryName[First[WaveletWareFile]];
	*)
	(* Next retrieve list of all audio files *)
	(*DataDirectory=PackageDirectory<>"Data/";*)
	DataDirectory=PackageDirectory[DataType->Data];
	SetDirectory[DataDirectory];
	files=Map[StringJoin[DataDirectory,#]&,Union[FileNames[],FileNames["*",{"*"},Infinity]]];
	files=Select[files,MemberQ[DataFormats,FileFormat[#]]&];
	SetDirectory[HomeDirectory];
	
	(* Display audio info if requested. *)
	
	
	If[TrueFalse[OptionValue[DataInfo,DisplayInfo]],
		type=Map[FileFormat,files];
		filenames=Map[FileNameDrop[#,FileNameDepth[DataDirectory]]&,files];
		Print["Information for Data Files in the WaveletWare Package\n",TableForm[Transpose[{filenames,type}],TableHeadings->{None,{"Data File","Type"}},TableAlignments->{Center,Center},TableSpacing->{5,5}]];
	];

	Return[files];
];

PackageDirectory[OptionsPattern[]]:=Module[{WaveletWareFile,type,dir},
	type=OptionValue[PackageDirectory,DataType];
	If[!MemberQ[{Images,Sounds,Data,All},type],Message[PackageDirectory::"baddirectory"];type=All];
	(* First find package directory *)
	WaveletWareFile=Complement[Map[FindFile[#<>"WaveletWare.m"]&,Map[StringJoin[#,"/WaveletWare/"]&,$Path]],{$Failed}];
	If[Length[WaveletWareFile]==0,Message[PackageDirectory::"packagenotfound"];Return[{}]];
	dir=DirectoryName[First[WaveletWareFile]];
	If[type===All,
		Return[dir],
		Return[dir<>ToString[type]<>"/"]
	];
];

WaveletMatrix[h_,{rows_,cols_},OptionsPattern[]]:=Module[{offset,block,row,len,lent,k,top,parity,g,bot},
	
	(* Check validity of the filter or filter pair h *)
	If[!((VectorQ[h] && EvenQ[Length[h]]) || (AllTrue[h,VectorQ] && Length[h]==2 && (AllTrue[Map[Length,h],EvenQ] || AllTrue[Map[Length,h],OddQ]))),Message[WaveletMatrix::"badfilter"];Return[{}]];

	(* Check that the dimensions are even positive integers *)
	If[!AllTrue[{rows,cols},(IntegerQ[#]&&EvenQ[#]&&Positive[#])&],Message[WaveletMatrix::"baddimensions"];Return[{}]];
	{len,lent}=If[VectorQ[h],{Length[h],0},Map[Length,h]];
	If[cols<len || cols<lent,Message[WaveletMatrix::"badcolumns"];Return[{}]];
	
	{offset,block}=OptionValue[WaveletMatrix,{Shift,MatrixBlock}];
	
	(* Check the validity of the offset value *)
	If[!(IntegerQ[offset] && Abs[offset]<=cols),Message[WaveletMatrix::"badoffset"];offset=0];
	
	(* Check the validity of the block value *)
	If[!(block===Lowpass || block===Highpass),block=All];
	
	(* Create the lowpass block *)
	If[(block===All || block===Lowpass),
		(* Do the lowpass block *)
		row=If[VectorQ[h],
			RotateRight[PadRight[Reverse[h],cols],offset],
			RotateLeft[PadRight[Last[h],cols],Which[EvenQ[lent],lent/2-1,True,(lent-1)/2]]
		];
		top=Table[RotateRight[row,2*k],{k,0,rows/2-1}];
	];
	
	If[(block===All || block===Highpass),
		(* Do the highpass block *)
		g=If[VectorQ[h],
			h*Table[(-1)^k,{k,1,len}],
			parity=Which[AllTrue[{len,lent},EvenQ],2,AllTrue[{len,lent},OddQ],1,True,Message[WaveletMatrix::"badparity"];Return[{}]];
			First[h]*Table[(-1)^k,{k,2-(parity+len)/2,(len-parity)/2+1}]
		];
		row=If[VectorQ[h],
			RotateRight[PadRight[g,cols],offset],
			RotateLeft[PadRight[g,cols],Which[parity==1,(len-3)/2,True,len/2-1]]
		];			
		bot=Table[RotateRight[row,2*k],{k,0,rows/2-1}];
	];
	
	Return[Which[block===Lowpass,top,block===Highpass,bot,True,Join[top,bot]]];
];

WaveletVectorToList[v_,OptionsPattern[]]:=Module[{datatype,its,maxits,lst,f},
	(* See if the data are in the correct format *)
	{datatype,maxits}=CheckData[v];
	If[datatype!=1,Message[WaveletVectorToList::"badinput"];Return[v]];
	
	(* Get the number of iterations and make sure it will work *)
	its=OptionValue[WaveletVectorToList,NumIterations];
	If[!CheckIterations[its,maxits],Message[WaveletVectorToList::"baditeration",its,maxits];its=maxits];
	
	If[its==0,Return[v]];
	
	lst=Partition[v,Length[v]/2];
	f[x_]:=Join[Partition[First[x],Length[First[x]]/2],Drop[x,1]];
	
	Return[Nest[f,lst,its-1]];
];

WaveletListToVector[v_]:=Flatten[v];

WaveletMatrixToList[a_,OptionsPattern[]]:=Module[{datatype,maxits,its,f,b,v},
	
	(* Check if the input is a matrix *)
	{datatype,maxits}=CheckData[a];
	If[datatype!=2,Message[WaveletMatrixToList::"badinput"];Return[a];];
	
	(* Determine if the number of iterations supplied is valid *)
	its=OptionValue[WaveletMatrixToList,NumIterations];
	If[!CheckIterations[its,maxits],Message[WaveletMatrixToList::"baditerations",its,maxits];its=maxits];
	
	If[its==0,Return[a]];
	
	b = Flatten[Partition[a, Dimensions[a]/2], 1];
	If[its == 1, Return[Prepend[Partition[Drop[b, 1], 3], First[b]]]];

	f[t_] := Module[{x},
   		x = Flatten[Partition[First[t], Dimensions[First[t]]/2], 1];
   		Return[Join[x, Drop[t, 1]]]; 
   	];

	v = Nest[f, b, its - 1];
	Return[Prepend[Partition[Drop[v, 1], 3], First[v]]];
];

WaveletListToMatrix[a_,OptionsPattern[]]:=Module[{its,f},
	
	(* Make sure the number of iterations is a positive integer *)
	its=OptionValue[WaveletListToMatrix,NumIterations];
	If[!(IntegerQ[its] && its>=0),Message[WaveletListToMatrix::"baditerations"];Return[a]];
	
	(* Check if the input format is correct *)
	If[Length[a]!=its+1,Message[WaveletListToMatrix::"badinput","The input must be of the form {lp_n,hp_n,...,hp_1}"];Return[a]];
	If[Map[Dimensions,Drop[a,1]]==Map[Prepend[#,3]&,Map[Dimensions[a]*#&,Range[its]]]!=True,Message[WaveletListToMatrix::"badinput","The dimensions of the input is not of the correct form"];Return[a]];
	
	If[its==0,Return[a]];
	
	f[t_]:=Prepend[Drop[t, 2],ArrayFlatten[Partition[Join[{First[t]}, Flatten[Take[t, {2}], 1]], 2]]];
	
	Return[First[Nest[f, a, its]]];
];

WaveletTree[its_,OptionsPattern[]]:=Module[{t,dim,k},
	If[!(IntegerQ[its]&&NonNegative[its]),Message[WaveletTree::"baditeration"];Return[{}]];
	If[its==0,Return[{1}]];
	dim=OptionValue[WaveletTree,InputDimension];
	If[!(IntegerQ[dim]&&(dim==1)||(dim==2)),Message[WaveletTree::"baddimension"];Return[{}]];
	If[dim==1,
		t=Map[Table[DiscreteDelta[2-k],{k,1,2^#}]&,Range[its-1]];
		t=Prepend[Append[t,Table[DiscreteDelta[(k-1)*(k-2)],{k,1,2^its}]],0],
		t=Table[ConstantArray[0,2^k*{1,1}],{k,1,its}];
		t=Map[ReplacePart[#,{{1,2}->1,{2,1}->1,{2,2}->1}]&,t];
		t[[its,1,1]]=1;
		t=Prepend[t,0];
	];
	Return[t];
];

WaveletRegionList[t_,d___]:=Module[{f,type},
	(* The optional argument d is added to take care of the weird case when t={1}.  In this case, it could be a datatype 1 or 2 tree *)
	type=Flatten[Position[Map[CheckTree[t,#]&,Range[3]],_Integer]];
	If[Length[type]==0,Message[WaveletRegionList::"badtree"]; Return[{}]]; 
 	type=First[type];
 	If[type<3,
 		Return[If[First[t]==1,If[type==1&d==="",{{0,1}},{{0,1,1}}],Position[Rest[t],1]]],
		f[tr_,k_]:=If[First[tr]==1,{{k,0,1,1}},Map[Prepend[#,k]&,Position[Rest[tr],1]]];
		If[!Apply[SameQ,t],
			Return[Apply[Join,MapThread[f[#1,#2]&,{t,Range[3]}]]],
			Return[Apply[Join,Transpose[MapThread[f[#1,#2]&,{t,Range[3]}]]]]
		];
	];
];

WaveletRegionTake[a_,t___,iter_,OptionsPattern[]]:=Module[{datatype,maxits,size,return,its,tree,iternew,f,g},
	{datatype,maxits}=CheckData[a];
	If[!MemberQ[{1,2,3},datatype],Message[WaveletRegionTake::"badinput"];Return[{}]];
	size=Which[datatype==1,Length[a],datatype==2,Dimensions[a],True,Dimensions[First[a]]];
	
	(* A function to parse data, based on the iter value *)
	f[x_]:=Module[{i,p,q,r},
		Which[
			datatype==1,
				{p,q}=x;
				Return[Partition[a,size/2^p][[q]]],
			datatype==2,
				{p,q,r}=x;
				Return[Partition[a,size/2^p][[q,r]]],
			True,
				{i,p,q,r}=x;
				Return[Partition[a[[i]],size/2^p][[q,r]]]
		];
	];
	
	return=TrueFalse[OptionValue[WaveletRegionTake,ReturnIterationList]];
	
	(* This is the composite tree case *)
	If[IntegerQ[CheckTree[t,2]&&datatype==3],
		its=CheckTree[t,2];
		(* Did CheckTree return a value that is too big? *)
		If[!CheckIterations[its,maxits],Message[WaveletRegionTake::"baditerations"];Return[{}]];
		iternew=If[iter===All,WaveletRegionList[t,2],iter];
		If[!AllTrue[iternew,CheckIterationValue[#,its,t,2]&],Message[WaveletRegionTake::"baditeration"];Return[{}]];
		g[i_]:=Map[Prepend[i,#]&,Range[3]];
		iternew=Apply[Join,Map[g,iternew]];
		If[!return,Return[Map[f,iternew]],Return[{Map[f,iternew],iternew}]];
	];
	its=OptionValue[WaveletRegionTake,NumIterations];
	
	(* Take care of dataytpe<3 *)
	If[datatype<3,
		{its,tree}=If[t==="",{its,WaveletTree[its,InputDimension->datatype]},{CheckTree[t,datatype],t}];
		
		(* Check the value of its *)
		If[its==False,Message[WaveletRegionTake::"badtree"];Return[{}]];
		If[!CheckIterations[its,maxits],Message[WaveletRegionTake::"baditerations"];Return[{}]];
		iternew=If[iter===All,WaveletRegionList[tree,2],iter];
		If[!AllTrue[iternew,CheckIterationValue[#,its,tree,datatype]&],Message[WaveletRegionTake::"baditeration"];Return[{}]];
		If[!return,Return[Map[f,iternew]],Return[{Map[f,iternew],iternew}]];
	];
	(* Last case is when datatype=3 and there are three trees or a wavelet transform *)
	{its,tree}=If[t==="",{its,ConstantArray[WaveletTree[its,InputDimension->2],3]},{CheckTree[t,3],t}];
	(* Check iteration value *)
	If[its==False,Message[WaveletRegionTake::"badtree"];Return[{}]];
	If[!CheckIterations[its, maxits],Message[WaveletRegionTake::"baditerations"];Return[{}]];
	
	(* Check if the values for iter are okay *)
	iternew=If[iter===All,WaveletRegionList[tree],iter];
	If[!AllTrue[iternew,Length[#]==4&],Message[WaveletRegionTake::"baditeration"];Return[{}]];
	(* Take care of the case where the first element in the 4-tuple might be All *)
	g[i_]:=If[First[i]===All,Map[ReplacePart[i,1->#]&,Range[3]],ConstantArray[i,3]];
	iternew=DeleteDuplicates[Apply[Join,Map[g,iternew]]];
	(* Check iteration values integrity *)
	If[!AllTrue[Map[CheckIterationValue[Rest[#],its,tree[[First[#]]],2]&,iternew],#===True&],Message[WaveletRegionTake::"baditeration"];Return[{}]];
	If[!return,Return[Map[f,iternew]],Return[{Map[f,iternew],iternew}]];

];

TrueFalse[w_]:=If[w===True,True,False];

MaxIts[a_] := Module[{},
	If[!(VectorQ[a] || MatrixQ[a]),Message[MaxIts::"badinput"];Return[0]];
	If[VectorQ[a],Return[IntegerExponent[Length[a],2]]];
   	Return[Min[Map[IntegerExponent[#,2]&,Dimensions[a]]]];
   ];

CheckData[data_]:=Which[
	NumericQ[data],Return[{4,0}],
	StringQ[data],Return[{4,0}],
	!AllTrue[Flatten[data],NumericQ],Return[{4,0}],
	VectorQ[data],Return[{1,MaxIts[data]}],
	MatrixQ[data],Return[{2,MaxIts[data]}],
	AllTrue[data,MatrixQ]&&Map[Dimensions,data]==ConstantArray[Dimensions[First[data]],3],Return[{3,MaxIts[First[data]]}],
	True,Message[CheckData::"badinput"];Return[{4,0}]
];

CheckFilter[f_] := Module[{h, g, t, hp, len, idx},
   (* Return -1 if f is no type of filter, 1 if f is orthogonal, 2 if f is a biorthogonal filter pair *)
   
   If[VectorQ[f],
   	If[!EvenQ[Length[f]],Return[-1]];
    	h[w_]:=FiniteFourier[w,f,0];
    	g[w_]:=Simplify[(h[w]*h[-w]+h[w+Pi]*h[-w+Pi])/h[0]^2];
    	hp = h[Pi];
    	If[g[t]==1. && hp==0,Return[1],Return[-1]];
    ];
    
   If[AllTrue[f,VectorQ] && Length[f]==2,
   	If[!EvenQ[Apply[Subtract,Map[Length,f]]],Return[-1]];
    	len=Map[Length,f];
    	idx=If[OddQ[First[len]],Map[(1-#)/2&,len],Map[(1-#/2)&,len]];
    	h[w_]:=MapThread[FiniteFourier[w,#1,#2]&,{f,idx}];
    	g[w_]:=Simplify[(First[h[w]]*Last[h[-w]]+First[h[w+Pi]]*Last[h[-w+Pi]])/Apply[Times,h[0]]];
    	hp= Max[Abs[h[Pi]]];
    	If[Chop[g[t]]==1. && Chop[hp]==0,Return[2],Return[-1]];
    ];

	(* Input is not a filter *)   
   	Return[-1];
];

CheckIterations[i_,m_]:=If[!(IntegerQ[i]&&NonNegative[i])||i>m,Return[False],Return[True]];

CheckDataFilterSize[type_,data_,i_,h_]:=Module[{len},
	If[i==0,Return[True]];
	len=Which[type==1,{Length[data],Length[data]},type==2,Dimensions[data],type==3,Dimensions[First[data]],True,Return[False]];
	If[!AllTrue[len/2^i,IntegerQ],Return[False]];
	If[VectorQ[h]&&Length[h]>Min[len/2^(i-1)],Return[False]];
	If[AllTrue[h,VectorQ]&&Max[Map[Length,h]]>Min[len/2^(i-1)],Return[False]];
	Return[True];
];

CheckParity[n_]:=Which[
					AllTrue[n,(IntegerQ[#]&&OddQ[#]&&Positive[#])&],1,	
					AllTrue[n,(IntegerQ[#]&&EvenQ[#]&&Positive[#])&],2,
					True,0];
					
CheckTree[tree_,datatype_]:=Module[{f,len,g},
	If[!AllTrue[Flatten[tree],MemberQ[{0,1},#]&],Message[CheckTree::"badtree"];Return[False]];
	
	f[x_]:=Module[{t},
   		t=If[datatype==1,
   			Map[Mean,Partition[Last[x],2]],
   			Map[Mean[Flatten[#]]&,Partition[Last[x],{2,2}],{2}]
   		];
   		Return[Append[Drop[x,-2],t+Last[Drop[x,-1]]]];
   	];
	If[datatype==1,
		(*If[!IntegerQ[First[tree]],Return[False]];*)
		If[!AllTrue[Rest[tree],VectorQ],Return[False]];
		len=Length[Rest[tree]];
		If[Map[Length,Rest[tree]]!=PowerRange[2,2^len,2],Return[False]];
		If[First[Flatten[Nest[f,tree,len]]]!=1,Return[False]];
		Return[len];
	];
	
	g[x_]:=Module[{ln},
		(*If[!IntegerQ[First[x]],Return[False]];*)
		If[Length[x]==0,Return[False]]; (* This is the nasty case where datatype is 3 but a single tree was passed as x *)
		If[!AllTrue[Rest[x],MatrixQ],Return[False]];
		ln=Length[Rest[x]];
		If[Map[Dimensions,Rest[x]]!=Map[#*{1,1}&,PowerRange[2,2^ln,2]],Return[False]];
		If[First[Flatten[Nest[f,x,ln]]]!=1,Return[False]];
		Return[ln];
	];
	
	If[datatype==2,
		Return[g[tree]];
	];
	
	If[datatype==3,
		len=Map[g,tree];
		If[AllTrue[len,#==First[len]&],Return[First[len]],Return[False]];
	];
];

CheckIterationValue[iter_,its_,tree_,datatype_]:=Module[{p,q,r},
		(* datatype should be either 1 (vector) or 2 (matrix)*)
		If[First[tree]==1&&(iter=={0,1,1}||iter=={0,1}||iter==All),Return[True]];
   		If[iter===All,Return[True]];
   		If[Length[iter]!=datatype+1,Return[False]];
   		If[!AllTrue[iter,IntegerQ],Return[False]];
   		If[datatype==2,
   			{p,q,r}=iter;
   			If[(MemberQ[Range[its],p]&&AllTrue[{q,r}, MemberQ[Range[2^p],#]&]&&Rest[tree][[p,q,r]]==1),Return[True],Return[False]];
   		];
   		If[datatype==1,
   			{p,q}=iter;
   			If[(MemberQ[Range[its],p]&&MemberQ[Range[2^p],q]&&Rest[tree][[p,q]]==1),Return[True],Return[False]];
   		];
   			
	];

CheckColor[clr_,datatype_,together_]:=Module[{c},
	If[datatype==1||datatype==2||(datatype==3&&together),
		If[!ColorQ[clr],
			Message[CheckColor::"badcolor"];
			Return[{1,1,1}],
			c=ColorConvert[clr,"RGB"];
			Return[{c[[1]],c[[2]],c[[3]]}]
		];
	];
	If[datatype==3&&!together,
		If[ColorQ[clr],
			c=ColorConvert[clr,"RGB"];
			Return[ConstantArray[{c[[1]],c[[2]],c[[3]]},3]];
		];
		If[AllTrue[clr,ColorQ]&&Length[clr]==3,
			c=Map[ColorConvert[#,"RGB"]&,clr];
			Return[{{c[[1,1]],c[[1,2]],c[[1,3]]},{c[[2,1]],c[[2,2]],c[[2,3]]},{c[[3,1]],c[[3,2]],c[[3,3]]}}],
			Message[CheckColor::"badcolor"];
			Return[ConstantArray[1,{3,3}]];
		];
	];
];


(* Error Messages *)
FiniteFourier::badindex="Warning :: The starting index must be an integer - resetting the start index to 0."
PutCorner::badinput="The two inputs must be matrices - PutCorner failed."
PutCorner::baddimensions="Warning:: The dimensions of the second input matrix cannot be larger than the dimensions of the first input matrix - returning the first matrix."
GetCorner::badinput="The first input must be a matrix - GetCorner failed."
GetCorner::nonintegers="Warning:: At least on of `1` or `2` is not an integer - returning the input matrix."
GetCorner::baddimensions="Warning:: At least on of `1` or `2` exceeds the corresponding dimension of the input matrix - returning the input matrix."
ChopVector::badinput="The input must be a vector - ChopVector failed."
ChopVector::badpower="The power of 2 must be a nonnegative integer - ChopVector failed."
ChopVector::badlength="Warning :: The length `1` of the vector must be greater than or equal to `2` - returning the original vector."
DataInfo::packagenotfound="WaveletWare package not found in any $Path folders.  Check installation instructions."
PackageDirectory::baddirectory="Warning :: the value of  must be All, Images, Sounds, Data - resetting the value to All."
PackageDirectory::packagenotfound="WaveletWare package not found in any $Path folders.  Check installation instructions."
WaveletMatrix::badfilter="Either an orthogonal wavelet filter or a biorthogonal filter pair is expected - WaveletMatrix failed."
WaveletMatrix::baddimensions="The dimensions of the matrix must be even - Wavelet Matrix failed."
WaveletMatrix::badcolumns="The number of columns must be the larger than the length(es) of the input filter - WaveletMatrix failed."
WaveletMatrix::badoffset="Warning :: The offset must be an integer that in absolute value is less than or equal to the input value for columns - resetting offset to its default value (0)."
WaveletVectorToList::badinput="The input for WaveletVectorToList must be a vector - returning input."
WaveletVectorToList::baditeration="Warning :: The number of requested iterations, `1`, to be formed exceeds the number of maximum iterations (`2`) that can be performed on the input data - assigning NumIterations the value `2`."
WaveletMatrixToList::badinput="Warning :: The input for WaveletMatrixToList must be a numeric matrix - returning input."
WaveletMatrixToList::baditerations="Warning :: Either the dimensions of the matrix exceeds `1`, the number of iterations input, or the number of iterations exceeds the maximum number of iterations that can be performed on the matrix - resetting the number of iterations to `2`."
WaveletListToMatrix::badinput="`1` - returning input."
WaveletListToMatrix::baditerations="The number of iterations must be a nonnegative integer - returning the input."
WaveletTree::baditeration="The value for this argument must be a nonnegative integer - WaveletTree failed."
WaveletTree::baddimension="The value of InputDimension must be either 1 (for a vector) or 2 (for a matrix) - WaveletTree failed."
WaveletRegionList::badtree="The input is not a valid wavelet packet tree or list of three trees - WaveletRegionList failed."
WaveletRegionTake::badinput="The input for WaveletRegionTake is numeric and must be a matrix or a list of three matrices with equal dimensions - WaveletRegionPlot failed."
WaveletRegionTake::baditerations="The number of iterations provided or the number of iterations read from a packet tree is too large for the input data - WaveletRegionTake failed."
WaveletRegionTake::baditeration="The iteration value is not valid with respect to either the input packet tree(s) or a wavelet tree - WaveletRegionTake failed."
WaveletRegionTake::badtree="The input is not a valid wavelet packet tree or list of three trees - WaveletRegionTake failed."
MaxIts::badinput="The input must be either a vector or a matrix - returning 0."
CheckData::badinput="Warning :: The input data type is not a vector, matrix or list of three matrices of equal dimensions."
CheckTree::badtree="The input value for tree is not a valid wavelet packet tree."
CheckColor::badcolor="Warning :: The input must be either a single color or a list of three colors.  Each color must be a valid Mathematica color - resetting the color to its default value."

End[]
EndPackage[]